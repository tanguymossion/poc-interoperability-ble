// Auto-generated by ffigen. Do not modify.
//
// Bindings pour CoreBluetooth (iOS)
// Régénérer avec: dart run ffigen --config ffigen_ios.yaml
//
// ignore_for_file: type=lint
// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: unused_import
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_CoreBluetoothBindings_wrapListenerBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_CoreBluetoothBindings_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _CoreBluetoothBindings_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_CoreBluetoothBindings_wrapListenerBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_CoreBluetoothBindings_wrapBlockingBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _CoreBluetoothBindings_protocolTrampoline_fjrv01(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_CoreBluetoothBindings_wrapListenerBlock_1tz5yf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_CoreBluetoothBindings_wrapBlockingBlock_1tz5yf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _CoreBluetoothBindings_protocolTrampoline_1tz5yf(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ffi.Pointer<objc.ObjCObjectImpl> arg3,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_CoreBluetoothBindings_wrapListenerBlock_8jfq1p(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_CoreBluetoothBindings_wrapBlockingBlock_8jfq1p(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _CoreBluetoothBindings_protocolTrampoline_8jfq1p(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ffi.Pointer<objc.ObjCObjectImpl> arg4,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_CoreBluetoothBindings_wrapListenerBlock_o4q9mk(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_CoreBluetoothBindings_wrapBlockingBlock_o4q9mk(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Double,
    ffi.Bool,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _CoreBluetoothBindings_protocolTrampoline_o4q9mk(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  double arg3,
  bool arg4,
  ffi.Pointer<objc.ObjCObjectImpl> arg5,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_CoreBluetoothBindings_wrapListenerBlock_5ut4yu(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_CoreBluetoothBindings_wrapBlockingBlock_5ut4yu(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Long,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _CoreBluetoothBindings_protocolTrampoline_5ut4yu(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  int arg2,
  ffi.Pointer<objc.ObjCObjectImpl> arg3,
);

final class __CFUUID extends ffi.Opaque {}

enum NSXMLParserExternalEntityResolvingPolicy {
  NSXMLParserResolveExternalEntitiesNever(0),
  NSXMLParserResolveExternalEntitiesNoNetwork(1),
  NSXMLParserResolveExternalEntitiesSameOriginOnly(2),
  NSXMLParserResolveExternalEntitiesAlways(3);

  final int value;
  const NSXMLParserExternalEntityResolvingPolicy(this.value);

  static NSXMLParserExternalEntityResolvingPolicy fromValue(int value) =>
      switch (value) {
        0 => NSXMLParserResolveExternalEntitiesNever,
        1 => NSXMLParserResolveExternalEntitiesNoNetwork,
        2 => NSXMLParserResolveExternalEntitiesSameOriginOnly,
        3 => NSXMLParserResolveExternalEntitiesAlways,
        _ => throw ArgumentError(
          'Unknown value for NSXMLParserExternalEntityResolvingPolicy: $value',
        ),
      };
}

/// WARNING: NSUUID is a stub. To generate bindings for this class, include
/// NSUUID in your config's objc-interfaces list.
///
/// NSUUID
extension type NSUUID._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        objc.NSSecureCoding {
  /// Constructs a [NSUUID] that points to the same underlying object as [other].
  NSUUID.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSUUID',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
  }

  /// Constructs a [NSUUID] that wraps the given raw object pointer.
  NSUUID.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSUUID',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
  }
}

late final _class_CBManager = objc.getClass("CBManager");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
typedef instancetype = ffi.Pointer<objc.ObjCObjectImpl>;
typedef Dartinstancetype = objc.ObjCObject;
late final _sel_init = objc.registerName("init");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

enum CBManagerState {
  CBManagerStateUnknown(0),
  CBManagerStateResetting(1),
  CBManagerStateUnsupported(2),
  CBManagerStateUnauthorized(3),
  CBManagerStatePoweredOff(4),
  CBManagerStatePoweredOn(5);

  final int value;
  const CBManagerState(this.value);

  static CBManagerState fromValue(int value) => switch (value) {
    0 => CBManagerStateUnknown,
    1 => CBManagerStateResetting,
    2 => CBManagerStateUnsupported,
    3 => CBManagerStateUnauthorized,
    4 => CBManagerStatePoweredOff,
    5 => CBManagerStatePoweredOn,
    _ => throw ArgumentError('Unknown value for CBManagerState: $value'),
  };
}

late final _sel_state = objc.registerName("state");
final _objc_msgSend_adxz8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

enum CBManagerAuthorization {
  CBManagerAuthorizationNotDetermined(0),
  CBManagerAuthorizationRestricted(1),
  CBManagerAuthorizationDenied(2),
  CBManagerAuthorizationAllowedAlways(3);

  final int value;
  const CBManagerAuthorization(this.value);

  static CBManagerAuthorization fromValue(int value) => switch (value) {
    0 => CBManagerAuthorizationNotDetermined,
    1 => CBManagerAuthorizationRestricted,
    2 => CBManagerAuthorizationDenied,
    3 => CBManagerAuthorizationAllowedAlways,
    _ => throw ArgumentError(
      'Unknown value for CBManagerAuthorization: $value',
    ),
  };
}

late final _sel_authorization = objc.registerName("authorization");
final _objc_msgSend_1pjspfw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSZone>,
      )
    >();
late final _sel_alloc = objc.registerName("alloc");

/// CBManager
extension type CBManager._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [CBManager] that points to the same underlying object as [other].
  CBManager.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('CBManager', iOS: (false, (10, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [CBManager] that wraps the given raw object pointer.
  CBManager.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBManager', iOS: (false, (10, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [CBManager].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_CBManager,
  );

  /// alloc
  static CBManager alloc() {
    final $ret = _objc_msgSend_151sglz(_class_CBManager, _sel_alloc);
    return CBManager.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBManager allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_CBManager,
      _sel_allocWithZone_,
      zone,
    );
    return CBManager.fromPointer($ret, retain: false, release: true);
  }

  /// authorization
  static CBManagerAuthorization getAuthorization$1() {
    objc.checkOsVersionInternal(
      'CBManager.authorization',
      iOS: (false, (13, 1, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1pjspfw(_class_CBManager, _sel_authorization);
    return CBManagerAuthorization.fromValue($ret);
  }

  /// new
  static CBManager new$() {
    final $ret = _objc_msgSend_151sglz(_class_CBManager, _sel_new);
    return CBManager.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of CBManager constructed with the default `new` method.
  CBManager() : this.as(new$().object$);
}

extension CBManager$Methods on CBManager {
  /// authorization
  CBManagerAuthorization get authorization {
    objc.checkOsVersionInternal(
      'CBManager.authorization',
      iOS: (false, (13, 0, 0)),
    );
    final $ret = _objc_msgSend_1pjspfw(object$.ref.pointer, _sel_authorization);
    return CBManagerAuthorization.fromValue($ret);
  }

  /// init
  CBManager init() {
    objc.checkOsVersionInternal(
      'CBManager.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return CBManager.fromPointer($ret, retain: false, release: true);
  }

  /// state
  CBManagerState get state {
    objc.checkOsVersionInternal('CBManager.state', iOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_adxz8(object$.ref.pointer, _sel_state);
    return CBManagerState.fromValue($ret);
  }
}

enum CBConnectionEvent {
  CBConnectionEventPeerDisconnected(0),
  CBConnectionEventPeerConnected(1);

  final int value;
  const CBConnectionEvent(this.value);

  static CBConnectionEvent fromValue(int value) => switch (value) {
    0 => CBConnectionEventPeerDisconnected,
    1 => CBConnectionEventPeerConnected,
    _ => throw ArgumentError('Unknown value for CBConnectionEvent: $value'),
  };
}

sealed class CBCentralManagerFeature {
  static const CBCentralManagerFeatureExtendedScanAndConnect = 1;
}

late final _class_CBCentralManager = objc.getClass("CBCentralManager");
late final _protocol_CBCentralManagerDelegate = objc.getProtocol(
  "CBCentralManagerDelegate",
);
late final _sel_conformsToProtocol_ = objc.registerName("conformsToProtocol:");
final _objc_msgSend_e3qsqz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCProtocolImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCProtocolImpl>,
      )
    >();
late final _sel_centralManagerDidUpdateState_ = objc.registerName(
  "centralManagerDidUpdateState:",
);
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBCentralManager {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CBCentralManager) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                CBCentralManager.fromPointer(arg1, retain: true, release: true),
              ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, CBCentralManager) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, CBCentralManager) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBCentralManager$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, CBCentralManager arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_centralManager_willRestoreState_ = objc.registerName(
  "centralManager:willRestoreState:",
);
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      objc.NSDictionary,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          objc.NSDictionary,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      objc.NSDictionary,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          objc.NSDictionary,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      objc.NSDictionary,
    )
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          objc.NSDictionary,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            CBCentralManager.fromPointer(arg1, retain: true, release: true),
            objc.NSDictionary.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      objc.NSDictionary,
    )
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        objc.NSDictionary.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBCentralManager,
        objc.NSDictionary,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      objc.NSDictionary,
    )
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        objc.NSDictionary.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        objc.NSDictionary.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapBlockingBlock_fjrv01(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBCentralManager,
        objc.NSDictionary,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, objc.NSDictionary)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CBCentralManager,
            objc.NSDictionary,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    CBCentralManager arg1,
    objc.NSDictionary arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _class_CBPeripheral = objc.getClass("CBPeripheral");
late final _protocol_CBPeripheralDelegate = objc.getProtocol(
  "CBPeripheralDelegate",
);
late final _sel_peripheralDidUpdateName_ = objc.registerName(
  "peripheralDidUpdateName:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CBPeripheral) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, CBPeripheral.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, CBPeripheral) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, CBPeripheral) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral)> {
  void call(ffi.Pointer<ffi.Void> arg0, CBPeripheral arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_peripheral_didModifyServices_ = objc.registerName(
  "peripheral:didModifyServices:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            CBPeripheral.fromPointer(arg1, retain: true, release: true),
            objc.NSArray.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        objc.NSArray.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        objc.NSArray.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        objc.NSArray.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapBlockingBlock_fjrv01(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSArray)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, CBPeripheral arg1, objc.NSArray arg2) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_peripheralDidUpdateRSSI_error_ = objc.registerName(
  "peripheralDidUpdateRSSI:error:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            CBPeripheral.fromPointer(arg1, retain: true, release: true),
            arg2.address == 0
                ? null
                : objc.NSError.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapBlockingBlock_fjrv01(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSError?)
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    CBPeripheral arg1,
    objc.NSError? arg2,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_peripheral_didReadRSSI_error_ = objc.registerName(
  "peripheral:didReadRSSI:error:",
);
final _objc_msgSend_r8gdi7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      objc.NSNumber,
      objc.NSError?,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBPeripheral,
          objc.NSNumber,
          objc.NSError?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      objc.NSNumber,
      objc.NSError?,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBPeripheral,
          objc.NSNumber,
          objc.NSError?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      objc.NSNumber,
      objc.NSError?,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      objc.NSNumber,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBPeripheral,
          objc.NSNumber,
          objc.NSError?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            CBPeripheral.fromPointer(arg1, retain: true, release: true),
            objc.NSNumber.fromPointer(arg2, retain: true, release: true),
            arg3.address == 0
                ? null
                : objc.NSError.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      objc.NSNumber,
      objc.NSError?,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      objc.NSNumber,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        objc.NSNumber.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBPeripheral,
        objc.NSNumber,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      objc.NSNumber,
      objc.NSError?,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      objc.NSNumber,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        objc.NSNumber.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        objc.NSNumber.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBPeripheral,
        objc.NSNumber,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, objc.NSNumber, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CBPeripheral,
            objc.NSNumber,
            objc.NSError?,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    CBPeripheral arg1,
    objc.NSNumber arg2,
    objc.NSError? arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_peripheral_didDiscoverServices_ = objc.registerName(
  "peripheral:didDiscoverServices:",
);
late final _class_CBService = objc.getClass("CBService");
late final _sel_peripheral = objc.registerName("peripheral");
late final _sel_isPrimary = objc.registerName("isPrimary");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_includedServices = objc.registerName("includedServices");
late final _sel_characteristics = objc.registerName("characteristics");
late final _class_CBAttribute = objc.getClass("CBAttribute");
late final _class_CBUUID = objc.getClass("CBUUID");
late final _sel_data = objc.registerName("data");
late final _sel_UUIDString = objc.registerName("UUIDString");
late final _sel_UUIDWithString_ = objc.registerName("UUIDWithString:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_UUIDWithData_ = objc.registerName("UUIDWithData:");
late final _sel_UUIDWithCFUUID_ = objc.registerName("UUIDWithCFUUID:");
final _objc_msgSend_13euv58 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<__CFUUID>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<__CFUUID>,
      )
    >();
late final _sel_UUIDWithNSUUID_ = objc.registerName("UUIDWithNSUUID:");

/// CBUUID
extension type CBUUID._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [CBUUID] that points to the same underlying object as [other].
  CBUUID.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('CBUUID', iOS: (false, (5, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [CBUUID] that wraps the given raw object pointer.
  CBUUID.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBUUID', iOS: (false, (5, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [CBUUID].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_CBUUID,
  );

  /// UUIDWithCFUUID:
  static CBUUID UUIDWithCFUUID(ffi.Pointer<__CFUUID> theUUID) {
    objc.checkOsVersionInternal(
      'CBUUID.UUIDWithCFUUID:',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_13euv58(
      _class_CBUUID,
      _sel_UUIDWithCFUUID_,
      theUUID,
    );
    return CBUUID.fromPointer($ret, retain: true, release: true);
  }

  /// UUIDWithData:
  static CBUUID UUIDWithData(objc.NSData theData) {
    objc.checkOsVersionInternal(
      'CBUUID.UUIDWithData:',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_CBUUID,
      _sel_UUIDWithData_,
      theData.ref.pointer,
    );
    return CBUUID.fromPointer($ret, retain: true, release: true);
  }

  /// UUIDWithNSUUID:
  static CBUUID UUIDWithNSUUID(NSUUID theUUID) {
    objc.checkOsVersionInternal(
      'CBUUID.UUIDWithNSUUID:',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_CBUUID,
      _sel_UUIDWithNSUUID_,
      theUUID.ref.pointer,
    );
    return CBUUID.fromPointer($ret, retain: true, release: true);
  }

  /// UUIDWithString:
  static CBUUID UUIDWithString(objc.NSString theString) {
    objc.checkOsVersionInternal(
      'CBUUID.UUIDWithString:',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_CBUUID,
      _sel_UUIDWithString_,
      theString.ref.pointer,
    );
    return CBUUID.fromPointer($ret, retain: true, release: true);
  }

  /// alloc
  static CBUUID alloc() {
    final $ret = _objc_msgSend_151sglz(_class_CBUUID, _sel_alloc);
    return CBUUID.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBUUID allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_CBUUID,
      _sel_allocWithZone_,
      zone,
    );
    return CBUUID.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static CBUUID new$() {
    final $ret = _objc_msgSend_151sglz(_class_CBUUID, _sel_new);
    return CBUUID.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of CBUUID constructed with the default `new` method.
  CBUUID() : this.as(new$().object$);
}

extension CBUUID$Methods on CBUUID {
  /// UUIDString
  objc.NSString get UUIDString {
    objc.checkOsVersionInternal('CBUUID.UUIDString', iOS: (false, (7, 1, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_UUIDString);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// data
  objc.NSData get data {
    objc.checkOsVersionInternal('CBUUID.data', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_data);
    return objc.NSData.fromPointer($ret, retain: true, release: true);
  }

  /// init
  CBUUID init() {
    objc.checkOsVersionInternal(
      'CBUUID.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return CBUUID.fromPointer($ret, retain: false, release: true);
  }
}

late final _sel_UUID = objc.registerName("UUID");

/// CBAttribute
extension type CBAttribute._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [CBAttribute] that points to the same underlying object as [other].
  CBAttribute.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('CBAttribute', iOS: (false, (8, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [CBAttribute] that wraps the given raw object pointer.
  CBAttribute.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBAttribute', iOS: (false, (8, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [CBAttribute].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_CBAttribute,
  );

  /// alloc
  static CBAttribute alloc() {
    final $ret = _objc_msgSend_151sglz(_class_CBAttribute, _sel_alloc);
    return CBAttribute.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBAttribute allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_CBAttribute,
      _sel_allocWithZone_,
      zone,
    );
    return CBAttribute.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static CBAttribute new$() {
    final $ret = _objc_msgSend_151sglz(_class_CBAttribute, _sel_new);
    return CBAttribute.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of CBAttribute constructed with the default `new` method.
  CBAttribute() : this.as(new$().object$);
}

extension CBAttribute$Methods on CBAttribute {
  /// UUID
  CBUUID get UUID {
    objc.checkOsVersionInternal('CBAttribute.UUID', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_UUID);
    return CBUUID.fromPointer($ret, retain: true, release: true);
  }

  /// init
  CBAttribute init() {
    objc.checkOsVersionInternal(
      'CBAttribute.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return CBAttribute.fromPointer($ret, retain: false, release: true);
  }
}

/// CBService
extension type CBService._(objc.ObjCObject object$)
    implements objc.ObjCObject, CBAttribute {
  /// Constructs a [CBService] that points to the same underlying object as [other].
  CBService.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('CBService', iOS: (false, (5, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [CBService] that wraps the given raw object pointer.
  CBService.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBService', iOS: (false, (5, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [CBService].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_CBService,
  );

  /// alloc
  static CBService alloc() {
    final $ret = _objc_msgSend_151sglz(_class_CBService, _sel_alloc);
    return CBService.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBService allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_CBService,
      _sel_allocWithZone_,
      zone,
    );
    return CBService.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static CBService new$() {
    final $ret = _objc_msgSend_151sglz(_class_CBService, _sel_new);
    return CBService.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of CBService constructed with the default `new` method.
  CBService() : this.as(new$().object$);
}

extension CBService$Methods on CBService {
  /// characteristics
  objc.NSArray? get characteristics {
    objc.checkOsVersionInternal(
      'CBService.characteristics',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_characteristics,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// includedServices
  objc.NSArray? get includedServices {
    objc.checkOsVersionInternal(
      'CBService.includedServices',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_includedServices,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// init
  CBService init() {
    objc.checkOsVersionInternal(
      'CBService.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return CBService.fromPointer($ret, retain: false, release: true);
  }

  /// isPrimary
  bool get isPrimary {
    objc.checkOsVersionInternal('CBService.isPrimary', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isPrimary);
  }

  /// peripheral
  CBPeripheral? get peripheral {
    objc.checkOsVersionInternal(
      'CBService.peripheral',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_peripheral);
    return $ret.address == 0
        ? null
        : CBPeripheral.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_peripheral_didDiscoverIncludedServicesForService_error_ = objc
    .registerName("peripheral:didDiscoverIncludedServicesForService:error:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBService,
      objc.NSError?,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBPeripheral,
          CBService,
          objc.NSError?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBService,
      objc.NSError?,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBPeripheral,
          CBService,
          objc.NSError?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBService,
      objc.NSError?,
    )
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBPeripheral,
          CBService,
          objc.NSError?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            CBPeripheral.fromPointer(arg1, retain: true, release: true),
            CBService.fromPointer(arg2, retain: true, release: true),
            arg3.address == 0
                ? null
                : objc.NSError.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBService,
      objc.NSError?,
    )
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        CBService.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBPeripheral,
        CBService,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBService,
      objc.NSError?,
    )
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        CBService.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        CBService.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBPeripheral,
        CBService,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBService, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CBPeripheral,
            CBService,
            objc.NSError?,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    CBPeripheral arg1,
    CBService arg2,
    objc.NSError? arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_peripheral_didDiscoverCharacteristicsForService_error_ = objc
    .registerName("peripheral:didDiscoverCharacteristicsForService:error:");
late final _class_CBCharacteristic = objc.getClass("CBCharacteristic");
late final _sel_service = objc.registerName("service");

sealed class CBCharacteristicProperties {
  static const CBCharacteristicPropertyBroadcast = 1;
  static const CBCharacteristicPropertyRead = 2;
  static const CBCharacteristicPropertyWriteWithoutResponse = 4;
  static const CBCharacteristicPropertyWrite = 8;
  static const CBCharacteristicPropertyNotify = 16;
  static const CBCharacteristicPropertyIndicate = 32;
  static const CBCharacteristicPropertyAuthenticatedSignedWrites = 64;
  static const CBCharacteristicPropertyExtendedProperties = 128;
  static const CBCharacteristicPropertyNotifyEncryptionRequired = 256;
  static const CBCharacteristicPropertyIndicateEncryptionRequired = 512;
}

late final _sel_properties = objc.registerName("properties");
final _objc_msgSend_1f77v0o = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_value = objc.registerName("value");
late final _sel_descriptors = objc.registerName("descriptors");
late final _sel_isBroadcasted = objc.registerName("isBroadcasted");
late final _sel_isNotifying = objc.registerName("isNotifying");

/// CBCharacteristic
extension type CBCharacteristic._(objc.ObjCObject object$)
    implements objc.ObjCObject, CBAttribute {
  /// Constructs a [CBCharacteristic] that points to the same underlying object as [other].
  CBCharacteristic.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('CBCharacteristic', iOS: (false, (5, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [CBCharacteristic] that wraps the given raw object pointer.
  CBCharacteristic.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBCharacteristic', iOS: (false, (5, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [CBCharacteristic].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_CBCharacteristic,
  );

  /// alloc
  static CBCharacteristic alloc() {
    final $ret = _objc_msgSend_151sglz(_class_CBCharacteristic, _sel_alloc);
    return CBCharacteristic.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBCharacteristic allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_CBCharacteristic,
      _sel_allocWithZone_,
      zone,
    );
    return CBCharacteristic.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static CBCharacteristic new$() {
    final $ret = _objc_msgSend_151sglz(_class_CBCharacteristic, _sel_new);
    return CBCharacteristic.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of CBCharacteristic constructed with the default `new` method.
  CBCharacteristic() : this.as(new$().object$);
}

extension CBCharacteristic$Methods on CBCharacteristic {
  /// descriptors
  objc.NSArray? get descriptors {
    objc.checkOsVersionInternal(
      'CBCharacteristic.descriptors',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_descriptors);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// init
  CBCharacteristic init() {
    objc.checkOsVersionInternal(
      'CBCharacteristic.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return CBCharacteristic.fromPointer($ret, retain: false, release: true);
  }

  /// isBroadcasted
  bool get isBroadcasted {
    objc.checkOsVersionInternal(
      'CBCharacteristic.isBroadcasted',
      iOS: (false, (5, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isBroadcasted);
  }

  /// isNotifying
  bool get isNotifying {
    objc.checkOsVersionInternal(
      'CBCharacteristic.isNotifying',
      iOS: (false, (5, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isNotifying);
  }

  /// properties
  int get properties {
    objc.checkOsVersionInternal(
      'CBCharacteristic.properties',
      iOS: (false, (5, 0, 0)),
    );
    return _objc_msgSend_1f77v0o(object$.ref.pointer, _sel_properties);
  }

  /// service
  CBService? get service {
    objc.checkOsVersionInternal(
      'CBCharacteristic.service',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_service);
    return $ret.address == 0
        ? null
        : CBService.fromPointer($ret, retain: true, release: true);
  }

  /// value
  objc.NSData? get value {
    objc.checkOsVersionInternal(
      'CBCharacteristic.value',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_value);
    return $ret.address == 0
        ? null
        : objc.NSData.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_peripheral_didUpdateValueForCharacteristic_error_ = objc
    .registerName("peripheral:didUpdateValueForCharacteristic:error:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBCharacteristic, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBCharacteristic,
      objc.NSError?,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBPeripheral,
          CBCharacteristic,
          objc.NSError?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBCharacteristic,
      objc.NSError?,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBPeripheral,
          CBCharacteristic,
          objc.NSError?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBCharacteristic,
      objc.NSError?,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBCharacteristic,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBPeripheral,
          CBCharacteristic,
          objc.NSError?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            CBPeripheral.fromPointer(arg1, retain: true, release: true),
            CBCharacteristic.fromPointer(arg2, retain: true, release: true),
            arg3.address == 0
                ? null
                : objc.NSError.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBCharacteristic,
      objc.NSError?,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBCharacteristic,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        CBCharacteristic.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBPeripheral,
        CBCharacteristic,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBCharacteristic,
      objc.NSError?,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBCharacteristic,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        CBCharacteristic.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        CBCharacteristic.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBPeripheral,
        CBCharacteristic,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBCharacteristic, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CBPeripheral,
            CBCharacteristic,
            objc.NSError?,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    CBPeripheral arg1,
    CBCharacteristic arg2,
    objc.NSError? arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_peripheral_didWriteValueForCharacteristic_error_ = objc
    .registerName("peripheral:didWriteValueForCharacteristic:error:");
late final _sel_peripheral_didUpdateNotificationStateForCharacteristic_error_ =
    objc.registerName(
      "peripheral:didUpdateNotificationStateForCharacteristic:error:",
    );
late final _sel_peripheral_didDiscoverDescriptorsForCharacteristic_error_ = objc
    .registerName("peripheral:didDiscoverDescriptorsForCharacteristic:error:");
late final _class_CBDescriptor = objc.getClass("CBDescriptor");
late final _sel_characteristic = objc.registerName("characteristic");

/// CBDescriptor
extension type CBDescriptor._(objc.ObjCObject object$)
    implements objc.ObjCObject, CBAttribute {
  /// Constructs a [CBDescriptor] that points to the same underlying object as [other].
  CBDescriptor.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('CBDescriptor', iOS: (false, (5, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [CBDescriptor] that wraps the given raw object pointer.
  CBDescriptor.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBDescriptor', iOS: (false, (5, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [CBDescriptor].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_CBDescriptor,
  );

  /// alloc
  static CBDescriptor alloc() {
    final $ret = _objc_msgSend_151sglz(_class_CBDescriptor, _sel_alloc);
    return CBDescriptor.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBDescriptor allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_CBDescriptor,
      _sel_allocWithZone_,
      zone,
    );
    return CBDescriptor.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static CBDescriptor new$() {
    final $ret = _objc_msgSend_151sglz(_class_CBDescriptor, _sel_new);
    return CBDescriptor.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of CBDescriptor constructed with the default `new` method.
  CBDescriptor() : this.as(new$().object$);
}

extension CBDescriptor$Methods on CBDescriptor {
  /// characteristic
  CBCharacteristic? get characteristic {
    objc.checkOsVersionInternal(
      'CBDescriptor.characteristic',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_characteristic,
    );
    return $ret.address == 0
        ? null
        : CBCharacteristic.fromPointer($ret, retain: true, release: true);
  }

  /// init
  CBDescriptor init() {
    objc.checkOsVersionInternal(
      'CBDescriptor.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return CBDescriptor.fromPointer($ret, retain: false, release: true);
  }

  /// value
  objc.ObjCObject? get value {
    objc.checkOsVersionInternal('CBDescriptor.value', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_value);
    return $ret.address == 0
        ? null
        : objc.ObjCObject($ret, retain: true, release: true);
  }
}

late final _sel_peripheral_didUpdateValueForDescriptor_error_ = objc
    .registerName("peripheral:didUpdateValueForDescriptor:error:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBDescriptor,
      objc.NSError?,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBPeripheral,
          CBDescriptor,
          objc.NSError?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBDescriptor,
      objc.NSError?,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBPeripheral,
          CBDescriptor,
          objc.NSError?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBDescriptor,
      objc.NSError?,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBDescriptor,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBPeripheral,
          CBDescriptor,
          objc.NSError?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            CBPeripheral.fromPointer(arg1, retain: true, release: true),
            CBDescriptor.fromPointer(arg2, retain: true, release: true),
            arg3.address == 0
                ? null
                : objc.NSError.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBDescriptor,
      objc.NSError?,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBDescriptor,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        CBDescriptor.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBPeripheral,
        CBDescriptor,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBDescriptor,
      objc.NSError?,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBDescriptor,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        CBDescriptor.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        CBDescriptor.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBPeripheral,
        CBDescriptor,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBDescriptor, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CBPeripheral,
            CBDescriptor,
            objc.NSError?,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    CBPeripheral arg1,
    CBDescriptor arg2,
    objc.NSError? arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_peripheral_didWriteValueForDescriptor_error_ = objc
    .registerName("peripheral:didWriteValueForDescriptor:error:");
late final _sel_peripheralIsReadyToSendWriteWithoutResponse_ = objc
    .registerName("peripheralIsReadyToSendWriteWithoutResponse:");

/// WARNING: CBL2CAPChannel is a stub. To generate bindings for this class, include
/// CBL2CAPChannel in your config's objc-interfaces list.
///
/// CBL2CAPChannel
extension type CBL2CAPChannel._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [CBL2CAPChannel] that points to the same underlying object as [other].
  CBL2CAPChannel.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('CBL2CAPChannel', iOS: (false, (11, 0, 0)));
  }

  /// Constructs a [CBL2CAPChannel] that wraps the given raw object pointer.
  CBL2CAPChannel.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBL2CAPChannel', iOS: (false, (11, 0, 0)));
  }
}

late final _sel_peripheral_didOpenL2CAPChannel_error_ = objc.registerName(
  "peripheral:didOpenL2CAPChannel:error:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBL2CAPChannel?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBL2CAPChannel?,
      objc.NSError?,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBPeripheral,
          CBL2CAPChannel?,
          objc.NSError?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBL2CAPChannel?,
      objc.NSError?,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBPeripheral,
          CBL2CAPChannel?,
          objc.NSError?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBL2CAPChannel?,
      objc.NSError?,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBL2CAPChannel?,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBPeripheral,
          CBL2CAPChannel?,
          objc.NSError?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            CBPeripheral.fromPointer(arg1, retain: true, release: true),
            arg2.address == 0
                ? null
                : CBL2CAPChannel.fromPointer(arg2, retain: true, release: true),
            arg3.address == 0
                ? null
                : objc.NSError.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBL2CAPChannel?,
      objc.NSError?,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBL2CAPChannel?,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : CBL2CAPChannel.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBPeripheral,
        CBL2CAPChannel?,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBL2CAPChannel?,
      objc.NSError?,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBPeripheral,
      CBL2CAPChannel?,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : CBL2CAPChannel.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBPeripheral.fromPointer(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : CBL2CAPChannel.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBPeripheral,
        CBL2CAPChannel?,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBPeripheral, CBL2CAPChannel?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CBPeripheral,
            CBL2CAPChannel?,
            objc.NSError?,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    CBPeripheral arg1,
    CBL2CAPChannel? arg2,
    objc.NSError? arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2?.ref.pointer ?? ffi.nullptr,
        arg3?.ref.pointer ?? ffi.nullptr,
      );
}

/// CBPeripheralDelegate
extension type CBPeripheralDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [CBPeripheralDelegate] that points to the same underlying object as [other].
  CBPeripheralDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [CBPeripheralDelegate] that wraps the given raw object pointer.
  CBPeripheralDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CBPeripheralDelegate].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_CBPeripheralDelegate,
    );
  }
}

extension CBPeripheralDelegate$Methods on CBPeripheralDelegate {
  /// peripheral:didDiscoverCharacteristicsForService:error:
  void peripheral(
    CBPeripheral peripheral, {
    required CBService didDiscoverCharacteristicsForService,
    objc.NSError? error,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_peripheral_didDiscoverCharacteristicsForService_error_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBPeripheralDelegate',
        'peripheral:didDiscoverCharacteristicsForService:error:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_peripheral_didDiscoverCharacteristicsForService_error_,
      peripheral.ref.pointer,
      didDiscoverCharacteristicsForService.ref.pointer,
      error?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// peripheral:didDiscoverDescriptorsForCharacteristic:error:
  void peripheral$1(
    CBPeripheral peripheral, {
    required CBCharacteristic didDiscoverDescriptorsForCharacteristic,
    objc.NSError? error,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_peripheral_didDiscoverDescriptorsForCharacteristic_error_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBPeripheralDelegate',
        'peripheral:didDiscoverDescriptorsForCharacteristic:error:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_peripheral_didDiscoverDescriptorsForCharacteristic_error_,
      peripheral.ref.pointer,
      didDiscoverDescriptorsForCharacteristic.ref.pointer,
      error?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// peripheral:didDiscoverIncludedServicesForService:error:
  void peripheral$2(
    CBPeripheral peripheral, {
    required CBService didDiscoverIncludedServicesForService,
    objc.NSError? error,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_peripheral_didDiscoverIncludedServicesForService_error_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBPeripheralDelegate',
        'peripheral:didDiscoverIncludedServicesForService:error:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_peripheral_didDiscoverIncludedServicesForService_error_,
      peripheral.ref.pointer,
      didDiscoverIncludedServicesForService.ref.pointer,
      error?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// peripheral:didDiscoverServices:
  void peripheral$3(
    CBPeripheral peripheral, {
    objc.NSError? didDiscoverServices,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_peripheral_didDiscoverServices_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBPeripheralDelegate',
        'peripheral:didDiscoverServices:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_peripheral_didDiscoverServices_,
      peripheral.ref.pointer,
      didDiscoverServices?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// peripheral:didModifyServices:
  void peripheral$4(
    CBPeripheral peripheral, {
    required objc.NSArray didModifyServices,
  }) {
    objc.checkOsVersionInternal(
      'CBPeripheralDelegate.peripheral:didModifyServices:',
      iOS: (false, (7, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_peripheral_didModifyServices_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBPeripheralDelegate',
        'peripheral:didModifyServices:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_peripheral_didModifyServices_,
      peripheral.ref.pointer,
      didModifyServices.ref.pointer,
    );
  }

  /// peripheral:didOpenL2CAPChannel:error:
  void peripheral$5(
    CBPeripheral peripheral, {
    CBL2CAPChannel? didOpenL2CAPChannel,
    objc.NSError? error,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_peripheral_didOpenL2CAPChannel_error_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBPeripheralDelegate',
        'peripheral:didOpenL2CAPChannel:error:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_peripheral_didOpenL2CAPChannel_error_,
      peripheral.ref.pointer,
      didOpenL2CAPChannel?.ref.pointer ?? ffi.nullptr,
      error?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// peripheral:didReadRSSI:error:
  void peripheral$6(
    CBPeripheral peripheral, {
    required objc.NSNumber didReadRSSI,
    objc.NSError? error,
  }) {
    objc.checkOsVersionInternal(
      'CBPeripheralDelegate.peripheral:didReadRSSI:error:',
      iOS: (false, (8, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_peripheral_didReadRSSI_error_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBPeripheralDelegate',
        'peripheral:didReadRSSI:error:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_peripheral_didReadRSSI_error_,
      peripheral.ref.pointer,
      didReadRSSI.ref.pointer,
      error?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// peripheral:didUpdateNotificationStateForCharacteristic:error:
  void peripheral$7(
    CBPeripheral peripheral, {
    required CBCharacteristic didUpdateNotificationStateForCharacteristic,
    objc.NSError? error,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_peripheral_didUpdateNotificationStateForCharacteristic_error_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBPeripheralDelegate',
        'peripheral:didUpdateNotificationStateForCharacteristic:error:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_peripheral_didUpdateNotificationStateForCharacteristic_error_,
      peripheral.ref.pointer,
      didUpdateNotificationStateForCharacteristic.ref.pointer,
      error?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// peripheral:didUpdateValueForCharacteristic:error:
  void peripheral$8(
    CBPeripheral peripheral, {
    required CBCharacteristic didUpdateValueForCharacteristic,
    objc.NSError? error,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_peripheral_didUpdateValueForCharacteristic_error_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBPeripheralDelegate',
        'peripheral:didUpdateValueForCharacteristic:error:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_peripheral_didUpdateValueForCharacteristic_error_,
      peripheral.ref.pointer,
      didUpdateValueForCharacteristic.ref.pointer,
      error?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// peripheral:didUpdateValueForDescriptor:error:
  void peripheral$9(
    CBPeripheral peripheral, {
    required CBDescriptor didUpdateValueForDescriptor,
    objc.NSError? error,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_peripheral_didUpdateValueForDescriptor_error_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBPeripheralDelegate',
        'peripheral:didUpdateValueForDescriptor:error:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_peripheral_didUpdateValueForDescriptor_error_,
      peripheral.ref.pointer,
      didUpdateValueForDescriptor.ref.pointer,
      error?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// peripheral:didWriteValueForCharacteristic:error:
  void peripheral$10(
    CBPeripheral peripheral, {
    required CBCharacteristic didWriteValueForCharacteristic,
    objc.NSError? error,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_peripheral_didWriteValueForCharacteristic_error_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBPeripheralDelegate',
        'peripheral:didWriteValueForCharacteristic:error:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_peripheral_didWriteValueForCharacteristic_error_,
      peripheral.ref.pointer,
      didWriteValueForCharacteristic.ref.pointer,
      error?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// peripheral:didWriteValueForDescriptor:error:
  void peripheral$11(
    CBPeripheral peripheral, {
    required CBDescriptor didWriteValueForDescriptor,
    objc.NSError? error,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_peripheral_didWriteValueForDescriptor_error_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBPeripheralDelegate',
        'peripheral:didWriteValueForDescriptor:error:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_peripheral_didWriteValueForDescriptor_error_,
      peripheral.ref.pointer,
      didWriteValueForDescriptor.ref.pointer,
      error?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// peripheralDidUpdateName:
  void peripheralDidUpdateName(CBPeripheral peripheral) {
    objc.checkOsVersionInternal(
      'CBPeripheralDelegate.peripheralDidUpdateName:',
      iOS: (false, (6, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_peripheralDidUpdateName_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBPeripheralDelegate',
        'peripheralDidUpdateName:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_peripheralDidUpdateName_,
      peripheral.ref.pointer,
    );
  }

  /// peripheralDidUpdateRSSI:error:
  void peripheralDidUpdateRSSI(CBPeripheral peripheral, {objc.NSError? error}) {
    objc.checkOsVersionInternal(
      'CBPeripheralDelegate.peripheralDidUpdateRSSI:error:',
      iOS: (false, (5, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_peripheralDidUpdateRSSI_error_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBPeripheralDelegate',
        'peripheralDidUpdateRSSI:error:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_peripheralDidUpdateRSSI_error_,
      peripheral.ref.pointer,
      error?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// peripheralIsReadyToSendWriteWithoutResponse:
  void peripheralIsReadyToSendWriteWithoutResponse(CBPeripheral peripheral) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_peripheralIsReadyToSendWriteWithoutResponse_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBPeripheralDelegate',
        'peripheralIsReadyToSendWriteWithoutResponse:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_peripheralIsReadyToSendWriteWithoutResponse_,
      peripheral.ref.pointer,
    );
  }
}

interface class CBPeripheralDelegate$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.fromPointer(_protocol_CBPeripheralDelegate.cast());

  /// Builds an object that implements the CBPeripheralDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CBPeripheralDelegate implement({
    void Function(CBPeripheral, CBService, objc.NSError?)?
    peripheral_didDiscoverCharacteristicsForService_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didDiscoverDescriptorsForCharacteristic_error_,
    void Function(CBPeripheral, CBService, objc.NSError?)?
    peripheral_didDiscoverIncludedServicesForService_error_,
    void Function(CBPeripheral, objc.NSError?)? peripheral_didDiscoverServices_,
    void Function(CBPeripheral, objc.NSArray)? peripheral_didModifyServices_,
    void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?)?
    peripheral_didOpenL2CAPChannel_error_,
    void Function(CBPeripheral, objc.NSNumber, objc.NSError?)?
    peripheral_didReadRSSI_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didUpdateNotificationStateForCharacteristic_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didUpdateValueForCharacteristic_error_,
    void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
    peripheral_didUpdateValueForDescriptor_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didWriteValueForCharacteristic_error_,
    void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
    peripheral_didWriteValueForDescriptor_error_,
    void Function(CBPeripheral)? peripheralDidUpdateName_,
    void Function(CBPeripheral, objc.NSError?)? peripheralDidUpdateRSSI_error_,
    void Function(CBPeripheral)? peripheralIsReadyToSendWriteWithoutResponse_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'CBPeripheralDelegate');
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverCharacteristicsForService_error_
        .implement(
          builder,
          peripheral_didDiscoverCharacteristicsForService_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverDescriptorsForCharacteristic_error_
        .implement(
          builder,
          peripheral_didDiscoverDescriptorsForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverIncludedServicesForService_error_
        .implement(
          builder,
          peripheral_didDiscoverIncludedServicesForService_error_,
        );
    CBPeripheralDelegate$Builder.peripheral_didDiscoverServices_.implement(
      builder,
      peripheral_didDiscoverServices_,
    );
    CBPeripheralDelegate$Builder.peripheral_didModifyServices_.implement(
      builder,
      peripheral_didModifyServices_,
    );
    CBPeripheralDelegate$Builder.peripheral_didOpenL2CAPChannel_error_
        .implement(builder, peripheral_didOpenL2CAPChannel_error_);
    CBPeripheralDelegate$Builder.peripheral_didReadRSSI_error_.implement(
      builder,
      peripheral_didReadRSSI_error_,
    );
    CBPeripheralDelegate$Builder
        .peripheral_didUpdateNotificationStateForCharacteristic_error_
        .implement(
          builder,
          peripheral_didUpdateNotificationStateForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didUpdateValueForCharacteristic_error_
        .implement(builder, peripheral_didUpdateValueForCharacteristic_error_);
    CBPeripheralDelegate$Builder.peripheral_didUpdateValueForDescriptor_error_
        .implement(builder, peripheral_didUpdateValueForDescriptor_error_);
    CBPeripheralDelegate$Builder
        .peripheral_didWriteValueForCharacteristic_error_
        .implement(builder, peripheral_didWriteValueForCharacteristic_error_);
    CBPeripheralDelegate$Builder.peripheral_didWriteValueForDescriptor_error_
        .implement(builder, peripheral_didWriteValueForDescriptor_error_);
    CBPeripheralDelegate$Builder.peripheralDidUpdateName_.implement(
      builder,
      peripheralDidUpdateName_,
    );
    CBPeripheralDelegate$Builder.peripheralDidUpdateRSSI_error_.implement(
      builder,
      peripheralDidUpdateRSSI_error_,
    );
    CBPeripheralDelegate$Builder.peripheralIsReadyToSendWriteWithoutResponse_
        .implement(builder, peripheralIsReadyToSendWriteWithoutResponse_);
    builder.addProtocol($protocol);
    return CBPeripheralDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the CBPeripheralDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    void Function(CBPeripheral, CBService, objc.NSError?)?
    peripheral_didDiscoverCharacteristicsForService_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didDiscoverDescriptorsForCharacteristic_error_,
    void Function(CBPeripheral, CBService, objc.NSError?)?
    peripheral_didDiscoverIncludedServicesForService_error_,
    void Function(CBPeripheral, objc.NSError?)? peripheral_didDiscoverServices_,
    void Function(CBPeripheral, objc.NSArray)? peripheral_didModifyServices_,
    void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?)?
    peripheral_didOpenL2CAPChannel_error_,
    void Function(CBPeripheral, objc.NSNumber, objc.NSError?)?
    peripheral_didReadRSSI_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didUpdateNotificationStateForCharacteristic_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didUpdateValueForCharacteristic_error_,
    void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
    peripheral_didUpdateValueForDescriptor_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didWriteValueForCharacteristic_error_,
    void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
    peripheral_didWriteValueForDescriptor_error_,
    void Function(CBPeripheral)? peripheralDidUpdateName_,
    void Function(CBPeripheral, objc.NSError?)? peripheralDidUpdateRSSI_error_,
    void Function(CBPeripheral)? peripheralIsReadyToSendWriteWithoutResponse_,
    bool $keepIsolateAlive = true,
  }) {
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverCharacteristicsForService_error_
        .implement(
          builder,
          peripheral_didDiscoverCharacteristicsForService_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverDescriptorsForCharacteristic_error_
        .implement(
          builder,
          peripheral_didDiscoverDescriptorsForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverIncludedServicesForService_error_
        .implement(
          builder,
          peripheral_didDiscoverIncludedServicesForService_error_,
        );
    CBPeripheralDelegate$Builder.peripheral_didDiscoverServices_.implement(
      builder,
      peripheral_didDiscoverServices_,
    );
    CBPeripheralDelegate$Builder.peripheral_didModifyServices_.implement(
      builder,
      peripheral_didModifyServices_,
    );
    CBPeripheralDelegate$Builder.peripheral_didOpenL2CAPChannel_error_
        .implement(builder, peripheral_didOpenL2CAPChannel_error_);
    CBPeripheralDelegate$Builder.peripheral_didReadRSSI_error_.implement(
      builder,
      peripheral_didReadRSSI_error_,
    );
    CBPeripheralDelegate$Builder
        .peripheral_didUpdateNotificationStateForCharacteristic_error_
        .implement(
          builder,
          peripheral_didUpdateNotificationStateForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didUpdateValueForCharacteristic_error_
        .implement(builder, peripheral_didUpdateValueForCharacteristic_error_);
    CBPeripheralDelegate$Builder.peripheral_didUpdateValueForDescriptor_error_
        .implement(builder, peripheral_didUpdateValueForDescriptor_error_);
    CBPeripheralDelegate$Builder
        .peripheral_didWriteValueForCharacteristic_error_
        .implement(builder, peripheral_didWriteValueForCharacteristic_error_);
    CBPeripheralDelegate$Builder.peripheral_didWriteValueForDescriptor_error_
        .implement(builder, peripheral_didWriteValueForDescriptor_error_);
    CBPeripheralDelegate$Builder.peripheralDidUpdateName_.implement(
      builder,
      peripheralDidUpdateName_,
    );
    CBPeripheralDelegate$Builder.peripheralDidUpdateRSSI_error_.implement(
      builder,
      peripheralDidUpdateRSSI_error_,
    );
    CBPeripheralDelegate$Builder.peripheralIsReadyToSendWriteWithoutResponse_
        .implement(builder, peripheralIsReadyToSendWriteWithoutResponse_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the CBPeripheralDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CBPeripheralDelegate implementAsListener({
    void Function(CBPeripheral, CBService, objc.NSError?)?
    peripheral_didDiscoverCharacteristicsForService_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didDiscoverDescriptorsForCharacteristic_error_,
    void Function(CBPeripheral, CBService, objc.NSError?)?
    peripheral_didDiscoverIncludedServicesForService_error_,
    void Function(CBPeripheral, objc.NSError?)? peripheral_didDiscoverServices_,
    void Function(CBPeripheral, objc.NSArray)? peripheral_didModifyServices_,
    void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?)?
    peripheral_didOpenL2CAPChannel_error_,
    void Function(CBPeripheral, objc.NSNumber, objc.NSError?)?
    peripheral_didReadRSSI_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didUpdateNotificationStateForCharacteristic_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didUpdateValueForCharacteristic_error_,
    void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
    peripheral_didUpdateValueForDescriptor_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didWriteValueForCharacteristic_error_,
    void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
    peripheral_didWriteValueForDescriptor_error_,
    void Function(CBPeripheral)? peripheralDidUpdateName_,
    void Function(CBPeripheral, objc.NSError?)? peripheralDidUpdateRSSI_error_,
    void Function(CBPeripheral)? peripheralIsReadyToSendWriteWithoutResponse_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'CBPeripheralDelegate');
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverCharacteristicsForService_error_
        .implementAsListener(
          builder,
          peripheral_didDiscoverCharacteristicsForService_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverDescriptorsForCharacteristic_error_
        .implementAsListener(
          builder,
          peripheral_didDiscoverDescriptorsForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverIncludedServicesForService_error_
        .implementAsListener(
          builder,
          peripheral_didDiscoverIncludedServicesForService_error_,
        );
    CBPeripheralDelegate$Builder.peripheral_didDiscoverServices_
        .implementAsListener(builder, peripheral_didDiscoverServices_);
    CBPeripheralDelegate$Builder.peripheral_didModifyServices_
        .implementAsListener(builder, peripheral_didModifyServices_);
    CBPeripheralDelegate$Builder.peripheral_didOpenL2CAPChannel_error_
        .implementAsListener(builder, peripheral_didOpenL2CAPChannel_error_);
    CBPeripheralDelegate$Builder.peripheral_didReadRSSI_error_
        .implementAsListener(builder, peripheral_didReadRSSI_error_);
    CBPeripheralDelegate$Builder
        .peripheral_didUpdateNotificationStateForCharacteristic_error_
        .implementAsListener(
          builder,
          peripheral_didUpdateNotificationStateForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didUpdateValueForCharacteristic_error_
        .implementAsListener(
          builder,
          peripheral_didUpdateValueForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder.peripheral_didUpdateValueForDescriptor_error_
        .implementAsListener(
          builder,
          peripheral_didUpdateValueForDescriptor_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didWriteValueForCharacteristic_error_
        .implementAsListener(
          builder,
          peripheral_didWriteValueForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder.peripheral_didWriteValueForDescriptor_error_
        .implementAsListener(
          builder,
          peripheral_didWriteValueForDescriptor_error_,
        );
    CBPeripheralDelegate$Builder.peripheralDidUpdateName_.implementAsListener(
      builder,
      peripheralDidUpdateName_,
    );
    CBPeripheralDelegate$Builder.peripheralDidUpdateRSSI_error_
        .implementAsListener(builder, peripheralDidUpdateRSSI_error_);
    CBPeripheralDelegate$Builder.peripheralIsReadyToSendWriteWithoutResponse_
        .implementAsListener(
          builder,
          peripheralIsReadyToSendWriteWithoutResponse_,
        );
    builder.addProtocol($protocol);
    return CBPeripheralDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the CBPeripheralDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(
    objc.ObjCProtocolBuilder builder, {
    void Function(CBPeripheral, CBService, objc.NSError?)?
    peripheral_didDiscoverCharacteristicsForService_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didDiscoverDescriptorsForCharacteristic_error_,
    void Function(CBPeripheral, CBService, objc.NSError?)?
    peripheral_didDiscoverIncludedServicesForService_error_,
    void Function(CBPeripheral, objc.NSError?)? peripheral_didDiscoverServices_,
    void Function(CBPeripheral, objc.NSArray)? peripheral_didModifyServices_,
    void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?)?
    peripheral_didOpenL2CAPChannel_error_,
    void Function(CBPeripheral, objc.NSNumber, objc.NSError?)?
    peripheral_didReadRSSI_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didUpdateNotificationStateForCharacteristic_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didUpdateValueForCharacteristic_error_,
    void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
    peripheral_didUpdateValueForDescriptor_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didWriteValueForCharacteristic_error_,
    void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
    peripheral_didWriteValueForDescriptor_error_,
    void Function(CBPeripheral)? peripheralDidUpdateName_,
    void Function(CBPeripheral, objc.NSError?)? peripheralDidUpdateRSSI_error_,
    void Function(CBPeripheral)? peripheralIsReadyToSendWriteWithoutResponse_,
    bool $keepIsolateAlive = true,
  }) {
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverCharacteristicsForService_error_
        .implementAsListener(
          builder,
          peripheral_didDiscoverCharacteristicsForService_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverDescriptorsForCharacteristic_error_
        .implementAsListener(
          builder,
          peripheral_didDiscoverDescriptorsForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverIncludedServicesForService_error_
        .implementAsListener(
          builder,
          peripheral_didDiscoverIncludedServicesForService_error_,
        );
    CBPeripheralDelegate$Builder.peripheral_didDiscoverServices_
        .implementAsListener(builder, peripheral_didDiscoverServices_);
    CBPeripheralDelegate$Builder.peripheral_didModifyServices_
        .implementAsListener(builder, peripheral_didModifyServices_);
    CBPeripheralDelegate$Builder.peripheral_didOpenL2CAPChannel_error_
        .implementAsListener(builder, peripheral_didOpenL2CAPChannel_error_);
    CBPeripheralDelegate$Builder.peripheral_didReadRSSI_error_
        .implementAsListener(builder, peripheral_didReadRSSI_error_);
    CBPeripheralDelegate$Builder
        .peripheral_didUpdateNotificationStateForCharacteristic_error_
        .implementAsListener(
          builder,
          peripheral_didUpdateNotificationStateForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didUpdateValueForCharacteristic_error_
        .implementAsListener(
          builder,
          peripheral_didUpdateValueForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder.peripheral_didUpdateValueForDescriptor_error_
        .implementAsListener(
          builder,
          peripheral_didUpdateValueForDescriptor_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didWriteValueForCharacteristic_error_
        .implementAsListener(
          builder,
          peripheral_didWriteValueForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder.peripheral_didWriteValueForDescriptor_error_
        .implementAsListener(
          builder,
          peripheral_didWriteValueForDescriptor_error_,
        );
    CBPeripheralDelegate$Builder.peripheralDidUpdateName_.implementAsListener(
      builder,
      peripheralDidUpdateName_,
    );
    CBPeripheralDelegate$Builder.peripheralDidUpdateRSSI_error_
        .implementAsListener(builder, peripheralDidUpdateRSSI_error_);
    CBPeripheralDelegate$Builder.peripheralIsReadyToSendWriteWithoutResponse_
        .implementAsListener(
          builder,
          peripheralIsReadyToSendWriteWithoutResponse_,
        );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the CBPeripheralDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CBPeripheralDelegate implementAsBlocking({
    void Function(CBPeripheral, CBService, objc.NSError?)?
    peripheral_didDiscoverCharacteristicsForService_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didDiscoverDescriptorsForCharacteristic_error_,
    void Function(CBPeripheral, CBService, objc.NSError?)?
    peripheral_didDiscoverIncludedServicesForService_error_,
    void Function(CBPeripheral, objc.NSError?)? peripheral_didDiscoverServices_,
    void Function(CBPeripheral, objc.NSArray)? peripheral_didModifyServices_,
    void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?)?
    peripheral_didOpenL2CAPChannel_error_,
    void Function(CBPeripheral, objc.NSNumber, objc.NSError?)?
    peripheral_didReadRSSI_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didUpdateNotificationStateForCharacteristic_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didUpdateValueForCharacteristic_error_,
    void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
    peripheral_didUpdateValueForDescriptor_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didWriteValueForCharacteristic_error_,
    void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
    peripheral_didWriteValueForDescriptor_error_,
    void Function(CBPeripheral)? peripheralDidUpdateName_,
    void Function(CBPeripheral, objc.NSError?)? peripheralDidUpdateRSSI_error_,
    void Function(CBPeripheral)? peripheralIsReadyToSendWriteWithoutResponse_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'CBPeripheralDelegate');
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverCharacteristicsForService_error_
        .implementAsBlocking(
          builder,
          peripheral_didDiscoverCharacteristicsForService_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverDescriptorsForCharacteristic_error_
        .implementAsBlocking(
          builder,
          peripheral_didDiscoverDescriptorsForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverIncludedServicesForService_error_
        .implementAsBlocking(
          builder,
          peripheral_didDiscoverIncludedServicesForService_error_,
        );
    CBPeripheralDelegate$Builder.peripheral_didDiscoverServices_
        .implementAsBlocking(builder, peripheral_didDiscoverServices_);
    CBPeripheralDelegate$Builder.peripheral_didModifyServices_
        .implementAsBlocking(builder, peripheral_didModifyServices_);
    CBPeripheralDelegate$Builder.peripheral_didOpenL2CAPChannel_error_
        .implementAsBlocking(builder, peripheral_didOpenL2CAPChannel_error_);
    CBPeripheralDelegate$Builder.peripheral_didReadRSSI_error_
        .implementAsBlocking(builder, peripheral_didReadRSSI_error_);
    CBPeripheralDelegate$Builder
        .peripheral_didUpdateNotificationStateForCharacteristic_error_
        .implementAsBlocking(
          builder,
          peripheral_didUpdateNotificationStateForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didUpdateValueForCharacteristic_error_
        .implementAsBlocking(
          builder,
          peripheral_didUpdateValueForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder.peripheral_didUpdateValueForDescriptor_error_
        .implementAsBlocking(
          builder,
          peripheral_didUpdateValueForDescriptor_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didWriteValueForCharacteristic_error_
        .implementAsBlocking(
          builder,
          peripheral_didWriteValueForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder.peripheral_didWriteValueForDescriptor_error_
        .implementAsBlocking(
          builder,
          peripheral_didWriteValueForDescriptor_error_,
        );
    CBPeripheralDelegate$Builder.peripheralDidUpdateName_.implementAsBlocking(
      builder,
      peripheralDidUpdateName_,
    );
    CBPeripheralDelegate$Builder.peripheralDidUpdateRSSI_error_
        .implementAsBlocking(builder, peripheralDidUpdateRSSI_error_);
    CBPeripheralDelegate$Builder.peripheralIsReadyToSendWriteWithoutResponse_
        .implementAsBlocking(
          builder,
          peripheralIsReadyToSendWriteWithoutResponse_,
        );
    builder.addProtocol($protocol);
    return CBPeripheralDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the CBPeripheralDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(
    objc.ObjCProtocolBuilder builder, {
    void Function(CBPeripheral, CBService, objc.NSError?)?
    peripheral_didDiscoverCharacteristicsForService_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didDiscoverDescriptorsForCharacteristic_error_,
    void Function(CBPeripheral, CBService, objc.NSError?)?
    peripheral_didDiscoverIncludedServicesForService_error_,
    void Function(CBPeripheral, objc.NSError?)? peripheral_didDiscoverServices_,
    void Function(CBPeripheral, objc.NSArray)? peripheral_didModifyServices_,
    void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?)?
    peripheral_didOpenL2CAPChannel_error_,
    void Function(CBPeripheral, objc.NSNumber, objc.NSError?)?
    peripheral_didReadRSSI_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didUpdateNotificationStateForCharacteristic_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didUpdateValueForCharacteristic_error_,
    void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
    peripheral_didUpdateValueForDescriptor_error_,
    void Function(CBPeripheral, CBCharacteristic, objc.NSError?)?
    peripheral_didWriteValueForCharacteristic_error_,
    void Function(CBPeripheral, CBDescriptor, objc.NSError?)?
    peripheral_didWriteValueForDescriptor_error_,
    void Function(CBPeripheral)? peripheralDidUpdateName_,
    void Function(CBPeripheral, objc.NSError?)? peripheralDidUpdateRSSI_error_,
    void Function(CBPeripheral)? peripheralIsReadyToSendWriteWithoutResponse_,
    bool $keepIsolateAlive = true,
  }) {
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverCharacteristicsForService_error_
        .implementAsBlocking(
          builder,
          peripheral_didDiscoverCharacteristicsForService_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverDescriptorsForCharacteristic_error_
        .implementAsBlocking(
          builder,
          peripheral_didDiscoverDescriptorsForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didDiscoverIncludedServicesForService_error_
        .implementAsBlocking(
          builder,
          peripheral_didDiscoverIncludedServicesForService_error_,
        );
    CBPeripheralDelegate$Builder.peripheral_didDiscoverServices_
        .implementAsBlocking(builder, peripheral_didDiscoverServices_);
    CBPeripheralDelegate$Builder.peripheral_didModifyServices_
        .implementAsBlocking(builder, peripheral_didModifyServices_);
    CBPeripheralDelegate$Builder.peripheral_didOpenL2CAPChannel_error_
        .implementAsBlocking(builder, peripheral_didOpenL2CAPChannel_error_);
    CBPeripheralDelegate$Builder.peripheral_didReadRSSI_error_
        .implementAsBlocking(builder, peripheral_didReadRSSI_error_);
    CBPeripheralDelegate$Builder
        .peripheral_didUpdateNotificationStateForCharacteristic_error_
        .implementAsBlocking(
          builder,
          peripheral_didUpdateNotificationStateForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didUpdateValueForCharacteristic_error_
        .implementAsBlocking(
          builder,
          peripheral_didUpdateValueForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder.peripheral_didUpdateValueForDescriptor_error_
        .implementAsBlocking(
          builder,
          peripheral_didUpdateValueForDescriptor_error_,
        );
    CBPeripheralDelegate$Builder
        .peripheral_didWriteValueForCharacteristic_error_
        .implementAsBlocking(
          builder,
          peripheral_didWriteValueForCharacteristic_error_,
        );
    CBPeripheralDelegate$Builder.peripheral_didWriteValueForDescriptor_error_
        .implementAsBlocking(
          builder,
          peripheral_didWriteValueForDescriptor_error_,
        );
    CBPeripheralDelegate$Builder.peripheralDidUpdateName_.implementAsBlocking(
      builder,
      peripheralDidUpdateName_,
    );
    CBPeripheralDelegate$Builder.peripheralDidUpdateRSSI_error_
        .implementAsBlocking(builder, peripheralDidUpdateRSSI_error_);
    CBPeripheralDelegate$Builder.peripheralIsReadyToSendWriteWithoutResponse_
        .implementAsBlocking(
          builder,
          peripheralIsReadyToSendWriteWithoutResponse_,
        );
    builder.addProtocol($protocol);
  }

  /// peripheral:didDiscoverCharacteristicsForService:error:
  static final peripheral_didDiscoverCharacteristicsForService_error_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBPeripheral, CBService, objc.NSError?)
      >(
        _protocol_CBPeripheralDelegate,
        _sel_peripheral_didDiscoverCharacteristicsForService_error_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBPeripheralDelegate,
          _sel_peripheral_didDiscoverCharacteristicsForService_error_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBPeripheral, CBService, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBService arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBService, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBService arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBService, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBService arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// peripheral:didDiscoverDescriptorsForCharacteristic:error:
  static final peripheral_didDiscoverDescriptorsForCharacteristic_error_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBPeripheral, CBCharacteristic, objc.NSError?)
      >(
        _protocol_CBPeripheralDelegate,
        _sel_peripheral_didDiscoverDescriptorsForCharacteristic_error_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBPeripheralDelegate,
          _sel_peripheral_didDiscoverDescriptorsForCharacteristic_error_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBCharacteristic arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBCharacteristic arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBCharacteristic arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// peripheral:didDiscoverIncludedServicesForService:error:
  static final peripheral_didDiscoverIncludedServicesForService_error_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBPeripheral, CBService, objc.NSError?)
      >(
        _protocol_CBPeripheralDelegate,
        _sel_peripheral_didDiscoverIncludedServicesForService_error_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBPeripheralDelegate,
          _sel_peripheral_didDiscoverIncludedServicesForService_error_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBPeripheral, CBService, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBService arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBService, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBService arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBService, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBService_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBService arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// peripheral:didDiscoverServices:
  static final peripheral_didDiscoverServices_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBPeripheral, objc.NSError?)
      >(
        _protocol_CBPeripheralDelegate,
        _sel_peripheral_didDiscoverServices_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBPeripheralDelegate,
          _sel_peripheral_didDiscoverServices_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBPeripheral, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                objc.NSError? arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(CBPeripheral, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                objc.NSError? arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(CBPeripheral, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                objc.NSError? arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// peripheral:didModifyServices:
  static final peripheral_didModifyServices_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBPeripheral, objc.NSArray)
      >(
        _protocol_CBPeripheralDelegate,
        _sel_peripheral_didModifyServices_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBPeripheralDelegate,
          _sel_peripheral_didModifyServices_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBPeripheral, objc.NSArray) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray.fromFunction(
              (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, objc.NSArray arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(CBPeripheral, objc.NSArray) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray.listener(
              (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, objc.NSArray arg2) =>
                  func(arg1, arg2),
            ),
        (void Function(CBPeripheral, objc.NSArray) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSArray.blocking(
              (ffi.Pointer<ffi.Void> _, CBPeripheral arg1, objc.NSArray arg2) =>
                  func(arg1, arg2),
            ),
      );

  /// peripheral:didOpenL2CAPChannel:error:
  static final peripheral_didOpenL2CAPChannel_error_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?)
      >(
        _protocol_CBPeripheralDelegate,
        _sel_peripheral_didOpenL2CAPChannel_error_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBPeripheralDelegate,
          _sel_peripheral_didOpenL2CAPChannel_error_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBL2CAPChannel? arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBL2CAPChannel? arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBL2CAPChannel?, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBL2CAPChannel_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBL2CAPChannel? arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// peripheral:didReadRSSI:error:
  static final peripheral_didReadRSSI_error_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBPeripheral, objc.NSNumber, objc.NSError?)
      >(
        _protocol_CBPeripheralDelegate,
        _sel_peripheral_didReadRSSI_error_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBPeripheralDelegate,
          _sel_peripheral_didReadRSSI_error_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBPeripheral, objc.NSNumber, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                objc.NSNumber arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, objc.NSNumber, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                objc.NSNumber arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, objc.NSNumber, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSNumber_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                objc.NSNumber arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// peripheral:didUpdateNotificationStateForCharacteristic:error:
  static final peripheral_didUpdateNotificationStateForCharacteristic_error_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBPeripheral, CBCharacteristic, objc.NSError?)
      >(
        _protocol_CBPeripheralDelegate,
        _sel_peripheral_didUpdateNotificationStateForCharacteristic_error_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBPeripheralDelegate,
          _sel_peripheral_didUpdateNotificationStateForCharacteristic_error_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBCharacteristic arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBCharacteristic arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBCharacteristic arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// peripheral:didUpdateValueForCharacteristic:error:
  static final peripheral_didUpdateValueForCharacteristic_error_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBPeripheral, CBCharacteristic, objc.NSError?)
      >(
        _protocol_CBPeripheralDelegate,
        _sel_peripheral_didUpdateValueForCharacteristic_error_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBPeripheralDelegate,
          _sel_peripheral_didUpdateValueForCharacteristic_error_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBCharacteristic arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBCharacteristic arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBCharacteristic arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// peripheral:didUpdateValueForDescriptor:error:
  static final peripheral_didUpdateValueForDescriptor_error_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBPeripheral, CBDescriptor, objc.NSError?)
      >(
        _protocol_CBPeripheralDelegate,
        _sel_peripheral_didUpdateValueForDescriptor_error_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBPeripheralDelegate,
          _sel_peripheral_didUpdateValueForDescriptor_error_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBPeripheral, CBDescriptor, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBDescriptor arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBDescriptor, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBDescriptor arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBDescriptor, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBDescriptor arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// peripheral:didWriteValueForCharacteristic:error:
  static final peripheral_didWriteValueForCharacteristic_error_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBPeripheral, CBCharacteristic, objc.NSError?)
      >(
        _protocol_CBPeripheralDelegate,
        _sel_peripheral_didWriteValueForCharacteristic_error_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBPeripheralDelegate,
          _sel_peripheral_didWriteValueForCharacteristic_error_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBCharacteristic arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBCharacteristic arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBCharacteristic, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBCharacteristic_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBCharacteristic arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// peripheral:didWriteValueForDescriptor:error:
  static final peripheral_didWriteValueForDescriptor_error_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBPeripheral, CBDescriptor, objc.NSError?)
      >(
        _protocol_CBPeripheralDelegate,
        _sel_peripheral_didWriteValueForDescriptor_error_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBPeripheralDelegate,
          _sel_peripheral_didWriteValueForDescriptor_error_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBPeripheral, CBDescriptor, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBDescriptor arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBDescriptor, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBDescriptor arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBPeripheral, CBDescriptor, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_CBDescriptor_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                CBDescriptor arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// peripheralDidUpdateName:
  static final peripheralDidUpdateName_ =
      objc.ObjCProtocolListenableMethod<void Function(CBPeripheral)>(
        _protocol_CBPeripheralDelegate,
        _sel_peripheralDidUpdateName_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_18v1jvf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBPeripheralDelegate,
          _sel_peripheralDidUpdateName_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBPeripheral) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral.fromFunction(
              (ffi.Pointer<ffi.Void> _, CBPeripheral arg1) => func(arg1),
            ),
        (void Function(CBPeripheral) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral.listener(
              (ffi.Pointer<ffi.Void> _, CBPeripheral arg1) => func(arg1),
            ),
        (void Function(CBPeripheral) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral.blocking(
              (ffi.Pointer<ffi.Void> _, CBPeripheral arg1) => func(arg1),
            ),
      );

  /// peripheralDidUpdateRSSI:error:
  static final peripheralDidUpdateRSSI_error_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBPeripheral, objc.NSError?)
      >(
        _protocol_CBPeripheralDelegate,
        _sel_peripheralDidUpdateRSSI_error_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBPeripheralDelegate,
          _sel_peripheralDidUpdateRSSI_error_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBPeripheral, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                objc.NSError? arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(CBPeripheral, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                objc.NSError? arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(CBPeripheral, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBPeripheral arg1,
                objc.NSError? arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// peripheralIsReadyToSendWriteWithoutResponse:
  static final peripheralIsReadyToSendWriteWithoutResponse_ =
      objc.ObjCProtocolListenableMethod<void Function(CBPeripheral)>(
        _protocol_CBPeripheralDelegate,
        _sel_peripheralIsReadyToSendWriteWithoutResponse_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_18v1jvf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBPeripheralDelegate,
          _sel_peripheralIsReadyToSendWriteWithoutResponse_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBPeripheral) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral.fromFunction(
              (ffi.Pointer<ffi.Void> _, CBPeripheral arg1) => func(arg1),
            ),
        (void Function(CBPeripheral) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral.listener(
              (ffi.Pointer<ffi.Void> _, CBPeripheral arg1) => func(arg1),
            ),
        (void Function(CBPeripheral) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBPeripheral.blocking(
              (ffi.Pointer<ffi.Void> _, CBPeripheral arg1) => func(arg1),
            ),
      );
}

late final _sel_delegate = objc.registerName("delegate");
late final _sel_setDelegate_ = objc.registerName("setDelegate:");
late final _sel_name = objc.registerName("name");
late final _sel_RSSI = objc.registerName("RSSI");

enum CBPeripheralState {
  CBPeripheralStateDisconnected(0),
  CBPeripheralStateConnecting(1),
  CBPeripheralStateConnected(2),
  CBPeripheralStateDisconnecting(3);

  final int value;
  const CBPeripheralState(this.value);

  static CBPeripheralState fromValue(int value) => switch (value) {
    0 => CBPeripheralStateDisconnected,
    1 => CBPeripheralStateConnecting,
    2 => CBPeripheralStateConnected,
    3 => CBPeripheralStateDisconnecting,
    _ => throw ArgumentError('Unknown value for CBPeripheralState: $value'),
  };
}

final _objc_msgSend_1vwb6jt = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_services = objc.registerName("services");
late final _sel_canSendWriteWithoutResponse = objc.registerName(
  "canSendWriteWithoutResponse",
);
late final _sel_ancsAuthorized = objc.registerName("ancsAuthorized");
late final _sel_readRSSI = objc.registerName("readRSSI");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_discoverServices_ = objc.registerName("discoverServices:");
late final _sel_discoverIncludedServices_forService_ = objc.registerName(
  "discoverIncludedServices:forService:",
);
late final _sel_discoverCharacteristics_forService_ = objc.registerName(
  "discoverCharacteristics:forService:",
);
late final _sel_readValueForCharacteristic_ = objc.registerName(
  "readValueForCharacteristic:",
);

enum CBCharacteristicWriteType {
  CBCharacteristicWriteWithResponse(0),
  CBCharacteristicWriteWithoutResponse(1);

  final int value;
  const CBCharacteristicWriteType(this.value);

  static CBCharacteristicWriteType fromValue(int value) => switch (value) {
    0 => CBCharacteristicWriteWithResponse,
    1 => CBCharacteristicWriteWithoutResponse,
    _ => throw ArgumentError(
      'Unknown value for CBCharacteristicWriteType: $value',
    ),
  };
}

late final _sel_maximumWriteValueLengthForType_ = objc.registerName(
  "maximumWriteValueLengthForType:",
);
final _objc_msgSend_1du2ky5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_writeValue_forCharacteristic_type_ = objc.registerName(
  "writeValue:forCharacteristic:type:",
);
final _objc_msgSend_188up4e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
      )
    >();
late final _sel_setNotifyValue_forCharacteristic_ = objc.registerName(
  "setNotifyValue:forCharacteristic:",
);
final _objc_msgSend_hk7n97 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_discoverDescriptorsForCharacteristic_ = objc.registerName(
  "discoverDescriptorsForCharacteristic:",
);
late final _sel_readValueForDescriptor_ = objc.registerName(
  "readValueForDescriptor:",
);
late final _sel_writeValue_forDescriptor_ = objc.registerName(
  "writeValue:forDescriptor:",
);
late final _sel_openL2CAPChannel_ = objc.registerName("openL2CAPChannel:");
final _objc_msgSend_15f11yh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Uint16,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _class_CBPeer = objc.getClass("CBPeer");
late final _sel_identifier = objc.registerName("identifier");

/// CBPeer
extension type CBPeer._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [CBPeer] that points to the same underlying object as [other].
  CBPeer.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('CBPeer', iOS: (false, (8, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [CBPeer] that wraps the given raw object pointer.
  CBPeer.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBPeer', iOS: (false, (8, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [CBPeer].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_CBPeer,
  );

  /// alloc
  static CBPeer alloc() {
    final $ret = _objc_msgSend_151sglz(_class_CBPeer, _sel_alloc);
    return CBPeer.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBPeer allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_CBPeer,
      _sel_allocWithZone_,
      zone,
    );
    return CBPeer.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static CBPeer new$() {
    final $ret = _objc_msgSend_151sglz(_class_CBPeer, _sel_new);
    return CBPeer.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of CBPeer constructed with the default `new` method.
  CBPeer() : this.as(new$().object$);
}

extension CBPeer$Methods on CBPeer {
  /// identifier
  NSUUID get identifier {
    objc.checkOsVersionInternal('CBPeer.identifier', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return NSUUID.fromPointer($ret, retain: true, release: true);
  }

  /// init
  CBPeer init() {
    objc.checkOsVersionInternal(
      'CBPeer.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return CBPeer.fromPointer($ret, retain: false, release: true);
  }
}

/// CBPeripheral
extension type CBPeripheral._(objc.ObjCObject object$)
    implements objc.ObjCObject, CBPeer {
  /// Constructs a [CBPeripheral] that points to the same underlying object as [other].
  CBPeripheral.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('CBPeripheral', iOS: (false, (5, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [CBPeripheral] that wraps the given raw object pointer.
  CBPeripheral.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBPeripheral', iOS: (false, (5, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [CBPeripheral].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_CBPeripheral,
  );

  /// alloc
  static CBPeripheral alloc() {
    final $ret = _objc_msgSend_151sglz(_class_CBPeripheral, _sel_alloc);
    return CBPeripheral.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBPeripheral allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_CBPeripheral,
      _sel_allocWithZone_,
      zone,
    );
    return CBPeripheral.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static CBPeripheral new$() {
    final $ret = _objc_msgSend_151sglz(_class_CBPeripheral, _sel_new);
    return CBPeripheral.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of CBPeripheral constructed with the default `new` method.
  CBPeripheral() : this.as(new$().object$);
}

extension CBPeripheral$Methods on CBPeripheral {
  /// RSSI
  objc.NSNumber? get RSSI {
    objc.checkOsVersionInternal('CBPeripheral.RSSI', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_RSSI);
    return $ret.address == 0
        ? null
        : objc.NSNumber.fromPointer($ret, retain: true, release: true);
  }

  /// ancsAuthorized
  bool get ancsAuthorized {
    objc.checkOsVersionInternal(
      'CBPeripheral.ancsAuthorized',
      iOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_ancsAuthorized);
  }

  /// canSendWriteWithoutResponse
  bool get canSendWriteWithoutResponse {
    objc.checkOsVersionInternal(
      'CBPeripheral.canSendWriteWithoutResponse',
      iOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_canSendWriteWithoutResponse,
    );
  }

  /// delegate
  CBPeripheralDelegate? get delegate {
    objc.checkOsVersionInternal(
      'CBPeripheral.delegate',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_delegate);
    return $ret.address == 0
        ? null
        : CBPeripheralDelegate.fromPointer($ret, retain: true, release: true);
  }

  /// discoverCharacteristics:forService:
  void discoverCharacteristics(
    objc.NSArray? characteristicUUIDs, {
    required CBService forService,
  }) {
    objc.checkOsVersionInternal(
      'CBPeripheral.discoverCharacteristics:forService:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_discoverCharacteristics_forService_,
      characteristicUUIDs?.ref.pointer ?? ffi.nullptr,
      forService.ref.pointer,
    );
  }

  /// discoverDescriptorsForCharacteristic:
  void discoverDescriptorsForCharacteristic(CBCharacteristic characteristic) {
    objc.checkOsVersionInternal(
      'CBPeripheral.discoverDescriptorsForCharacteristic:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_discoverDescriptorsForCharacteristic_,
      characteristic.ref.pointer,
    );
  }

  /// discoverIncludedServices:forService:
  void discoverIncludedServices(
    objc.NSArray? includedServiceUUIDs, {
    required CBService forService,
  }) {
    objc.checkOsVersionInternal(
      'CBPeripheral.discoverIncludedServices:forService:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_discoverIncludedServices_forService_,
      includedServiceUUIDs?.ref.pointer ?? ffi.nullptr,
      forService.ref.pointer,
    );
  }

  /// discoverServices:
  void discoverServices(objc.NSArray? serviceUUIDs) {
    objc.checkOsVersionInternal(
      'CBPeripheral.discoverServices:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_discoverServices_,
      serviceUUIDs?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// init
  CBPeripheral init() {
    objc.checkOsVersionInternal(
      'CBPeripheral.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return CBPeripheral.fromPointer($ret, retain: false, release: true);
  }

  /// maximumWriteValueLengthForType:
  int maximumWriteValueLengthForType(CBCharacteristicWriteType type) {
    objc.checkOsVersionInternal(
      'CBPeripheral.maximumWriteValueLengthForType:',
      iOS: (false, (9, 0, 0)),
    );
    return _objc_msgSend_1du2ky5(
      object$.ref.pointer,
      _sel_maximumWriteValueLengthForType_,
      type.value,
    );
  }

  /// name
  objc.NSString? get name {
    objc.checkOsVersionInternal('CBPeripheral.name', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_name);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// openL2CAPChannel:
  void openL2CAPChannel(int PSM) {
    objc.checkOsVersionInternal(
      'CBPeripheral.openL2CAPChannel:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_15f11yh(object$.ref.pointer, _sel_openL2CAPChannel_, PSM);
  }

  /// readRSSI
  void readRSSI() {
    objc.checkOsVersionInternal(
      'CBPeripheral.readRSSI',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_readRSSI);
  }

  /// readValueForCharacteristic:
  void readValueForCharacteristic(CBCharacteristic characteristic) {
    objc.checkOsVersionInternal(
      'CBPeripheral.readValueForCharacteristic:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_readValueForCharacteristic_,
      characteristic.ref.pointer,
    );
  }

  /// readValueForDescriptor:
  void readValueForDescriptor(CBDescriptor descriptor) {
    objc.checkOsVersionInternal(
      'CBPeripheral.readValueForDescriptor:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_readValueForDescriptor_,
      descriptor.ref.pointer,
    );
  }

  /// services
  objc.NSArray? get services {
    objc.checkOsVersionInternal(
      'CBPeripheral.services',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_services);
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// setDelegate:
  set delegate(CBPeripheralDelegate? value) {
    objc.checkOsVersionInternal(
      'CBPeripheral.setDelegate:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setDelegate_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setNotifyValue:forCharacteristic:
  void setNotifyValue(
    bool enabled, {
    required CBCharacteristic forCharacteristic,
  }) {
    objc.checkOsVersionInternal(
      'CBPeripheral.setNotifyValue:forCharacteristic:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_hk7n97(
      object$.ref.pointer,
      _sel_setNotifyValue_forCharacteristic_,
      enabled,
      forCharacteristic.ref.pointer,
    );
  }

  /// state
  CBPeripheralState get state {
    objc.checkOsVersionInternal('CBPeripheral.state', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1vwb6jt(object$.ref.pointer, _sel_state);
    return CBPeripheralState.fromValue($ret);
  }

  /// writeValue:forCharacteristic:type:
  void writeValue(
    objc.NSData data, {
    required CBCharacteristic forCharacteristic,
    required CBCharacteristicWriteType type,
  }) {
    objc.checkOsVersionInternal(
      'CBPeripheral.writeValue:forCharacteristic:type:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_188up4e(
      object$.ref.pointer,
      _sel_writeValue_forCharacteristic_type_,
      data.ref.pointer,
      forCharacteristic.ref.pointer,
      type.value,
    );
  }

  /// writeValue:forDescriptor:
  void writeValue$1(objc.NSData data, {required CBDescriptor forDescriptor}) {
    objc.checkOsVersionInternal(
      'CBPeripheral.writeValue:forDescriptor:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_writeValue_forDescriptor_,
      data.ref.pointer,
      forDescriptor.ref.pointer,
    );
  }
}

late final _sel_centralManager_didDiscoverPeripheral_advertisementData_RSSI_ =
    objc.registerName(
      "centralManager:didDiscoverPeripheral:advertisementData:RSSI:",
    );
final _objc_msgSend_mlcr8l = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, objc.NSDictionary, objc.NSNumber)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSDictionary,
      objc.NSNumber,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          CBPeripheral,
          objc.NSDictionary,
          objc.NSNumber,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSDictionary,
      objc.NSNumber,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ffi.Pointer<objc.ObjCObjectImpl> arg4,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          CBPeripheral,
          objc.NSDictionary,
          objc.NSNumber,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSDictionary,
      objc.NSNumber,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSDictionary,
      objc.NSNumber,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          CBPeripheral,
          objc.NSDictionary,
          objc.NSNumber,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCObjectImpl> arg4,
          ) => fn(
            arg0,
            CBCentralManager.fromPointer(arg1, retain: true, release: true),
            CBPeripheral.fromPointer(arg2, retain: true, release: true),
            objc.NSDictionary.fromPointer(arg3, retain: true, release: true),
            objc.NSNumber.fromPointer(arg4, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSDictionary,
      objc.NSNumber,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSDictionary,
      objc.NSNumber,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCObjectImpl> arg4,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        CBPeripheral.fromPointer(arg2, retain: false, release: true),
        objc.NSDictionary.fromPointer(arg3, retain: false, release: true),
        objc.NSNumber.fromPointer(arg4, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapListenerBlock_8jfq1p(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBCentralManager,
        CBPeripheral,
        objc.NSDictionary,
        objc.NSNumber,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSDictionary,
      objc.NSNumber,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSDictionary,
      objc.NSNumber,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCObjectImpl> arg4,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        CBPeripheral.fromPointer(arg2, retain: false, release: true),
        objc.NSDictionary.fromPointer(arg3, retain: false, release: true),
        objc.NSNumber.fromPointer(arg4, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCObjectImpl> arg4,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        CBPeripheral.fromPointer(arg2, retain: false, release: true),
        objc.NSDictionary.fromPointer(arg3, retain: false, release: true),
        objc.NSNumber.fromPointer(arg4, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapBlockingBlock_8jfq1p(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBCentralManager,
        CBPeripheral,
        objc.NSDictionary,
        objc.NSNumber,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCObjectImpl> arg4,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3, arg4);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCObjectImpl> arg4,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCObjectImpl> arg4,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCObjectImpl> arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCObjectImpl> arg4,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, objc.NSDictionary, objc.NSNumber)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CBCentralManager,
            CBPeripheral,
            objc.NSDictionary,
            objc.NSNumber,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    CBCentralManager arg1,
    CBPeripheral arg2,
    objc.NSDictionary arg3,
    objc.NSNumber arg4,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
                ffi.Pointer<objc.ObjCObjectImpl> arg4,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
        arg4.ref.pointer,
      );
}

late final _sel_centralManager_didConnectPeripheral_ = objc.registerName(
  "centralManager:didConnectPeripheral:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            CBCentralManager.fromPointer(arg1, retain: true, release: true),
            CBPeripheral.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        CBPeripheral.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        CBPeripheral.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        CBPeripheral.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapBlockingBlock_fjrv01(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CBCentralManager,
            CBPeripheral,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    CBCentralManager arg1,
    CBPeripheral arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_centralManager_didFailToConnectPeripheral_error_ = objc
    .registerName("centralManager:didFailToConnectPeripheral:error:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSError?,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          CBPeripheral,
          objc.NSError?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSError?,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          CBPeripheral,
          objc.NSError?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSError?,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          CBPeripheral,
          objc.NSError?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            CBCentralManager.fromPointer(arg1, retain: true, release: true),
            CBPeripheral.fromPointer(arg2, retain: true, release: true),
            arg3.address == 0
                ? null
                : objc.NSError.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSError?,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        CBPeripheral.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBCentralManager,
        CBPeripheral,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSError?,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        CBPeripheral.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        CBPeripheral.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBCentralManager,
        CBPeripheral,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CBCentralManager,
            CBPeripheral,
            objc.NSError?,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    CBCentralManager arg1,
    CBPeripheral arg2,
    objc.NSError? arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_centralManager_didDisconnectPeripheral_error_ = objc
    .registerName("centralManager:didDisconnectPeripheral:error:");
late final _sel_centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_ =
    objc.registerName(
      "centralManager:didDisconnectPeripheral:timestamp:isReconnecting:error:",
    );
final _objc_msgSend_1xnaqp0 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Double,
          ffi.Bool,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        double,
        bool,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, ffi.Double, ffi.Bool, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      ffi.Double,
      ffi.Bool,
      objc.NSError?,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          CBPeripheral,
          ffi.Double,
          ffi.Bool,
          objc.NSError?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      ffi.Double,
      ffi.Bool,
      objc.NSError?,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Double arg3,
          ffi.Bool arg4,
          ffi.Pointer<objc.ObjCObjectImpl> arg5,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          CBPeripheral,
          ffi.Double,
          ffi.Bool,
          objc.NSError?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      ffi.Double,
      ffi.Bool,
      objc.NSError?,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      double,
      bool,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          CBPeripheral,
          ffi.Double,
          ffi.Bool,
          objc.NSError?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            double arg3,
            bool arg4,
            ffi.Pointer<objc.ObjCObjectImpl> arg5,
          ) => fn(
            arg0,
            CBCentralManager.fromPointer(arg1, retain: true, release: true),
            CBPeripheral.fromPointer(arg2, retain: true, release: true),
            arg3,
            arg4,
            arg5.address == 0
                ? null
                : objc.NSError.fromPointer(arg5, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      ffi.Double,
      ffi.Bool,
      objc.NSError?,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      double,
      bool,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        double arg3,
        bool arg4,
        ffi.Pointer<objc.ObjCObjectImpl> arg5,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        CBPeripheral.fromPointer(arg2, retain: false, release: true),
        arg3,
        arg4,
        arg5.address == 0
            ? null
            : objc.NSError.fromPointer(arg5, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapListenerBlock_o4q9mk(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBCentralManager,
        CBPeripheral,
        ffi.Double,
        ffi.Bool,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      ffi.Double,
      ffi.Bool,
      objc.NSError?,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBPeripheral,
      double,
      bool,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        double arg3,
        bool arg4,
        ffi.Pointer<objc.ObjCObjectImpl> arg5,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        CBPeripheral.fromPointer(arg2, retain: false, release: true),
        arg3,
        arg4,
        arg5.address == 0
            ? null
            : objc.NSError.fromPointer(arg5, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        double arg3,
        bool arg4,
        ffi.Pointer<objc.ObjCObjectImpl> arg5,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        CBPeripheral.fromPointer(arg2, retain: false, release: true),
        arg3,
        arg4,
        arg5.address == 0
            ? null
            : objc.NSError.fromPointer(arg5, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapBlockingBlock_o4q9mk(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBCentralManager,
        CBPeripheral,
        ffi.Double,
        ffi.Bool,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    double arg3,
    bool arg4,
    ffi.Pointer<objc.ObjCObjectImpl> arg5,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          double,
          bool,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3, arg4, arg5);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Double,
      ffi.Bool,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Double,
            ffi.Bool,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    double arg3,
    bool arg4,
    ffi.Pointer<objc.ObjCObjectImpl> arg5,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            double,
            bool,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3, arg4, arg5);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Double,
      ffi.Bool,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Double,
            ffi.Bool,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Double,
      ffi.Bool,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Double,
            ffi.Bool,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    double arg3,
    bool arg4,
    ffi.Pointer<objc.ObjCObjectImpl> arg5,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Double arg3,
            ffi.Bool arg4,
            ffi.Pointer<objc.ObjCObjectImpl> arg5,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          double,
          bool,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3, arg4, arg5);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Double,
              ffi.Bool,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    double arg3,
    bool arg4,
    ffi.Pointer<objc.ObjCObjectImpl> arg5,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            double,
            bool,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3, arg4, arg5);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Double,
              ffi.Bool,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, CBPeripheral, ffi.Double, ffi.Bool, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CBCentralManager,
            CBPeripheral,
            ffi.Double,
            ffi.Bool,
            objc.NSError?,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    CBCentralManager arg1,
    CBPeripheral arg2,
    double arg3,
    bool arg4,
    objc.NSError? arg5,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Double arg3,
                ffi.Bool arg4,
                ffi.Pointer<objc.ObjCObjectImpl> arg5,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              double,
              bool,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3,
        arg4,
        arg5?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_centralManager_connectionEventDidOccur_forPeripheral_ = objc
    .registerName("centralManager:connectionEventDidOccur:forPeripheral:");
final _objc_msgSend_11np4se = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, ffi.Long, CBPeripheral)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      ffi.Long,
      CBPeripheral,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          ffi.Long,
          CBPeripheral,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      ffi.Long,
      CBPeripheral,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Long arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          ffi.Long,
          CBPeripheral,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      ffi.Long,
      CBPeripheral,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBConnectionEvent,
      CBPeripheral,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          CBCentralManager,
          ffi.Long,
          CBPeripheral,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            int arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            CBCentralManager.fromPointer(arg1, retain: true, release: true),
            CBConnectionEvent.fromValue(arg2),
            CBPeripheral.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      ffi.Long,
      CBPeripheral,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBConnectionEvent,
      CBPeripheral,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        int arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        CBConnectionEvent.fromValue(arg2),
        CBPeripheral.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapListenerBlock_5ut4yu(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBCentralManager,
        ffi.Long,
        CBPeripheral,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      ffi.Long,
      CBPeripheral,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      CBCentralManager,
      CBConnectionEvent,
      CBPeripheral,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        int arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        CBConnectionEvent.fromValue(arg2),
        CBPeripheral.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        int arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        CBCentralManager.fromPointer(arg1, retain: false, release: true),
        CBConnectionEvent.fromValue(arg2),
        CBPeripheral.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _CoreBluetoothBindings_wrapBlockingBlock_5ut4yu(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        CBCentralManager,
        ffi.Long,
        CBPeripheral,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    int arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          int,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    int arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            int,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    int arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Long arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          int,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    int arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            int,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CBCentralManager, ffi.Long, CBPeripheral)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            CBCentralManager,
            ffi.Long,
            CBPeripheral,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    CBCentralManager arg1,
    CBConnectionEvent arg2,
    CBPeripheral arg3,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Long arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          int,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.value, arg3.ref.pointer);
}

late final _sel_centralManager_didUpdateANCSAuthorizationForPeripheral_ = objc
    .registerName("centralManager:didUpdateANCSAuthorizationForPeripheral:");

/// CBCentralManagerDelegate
extension type CBCentralManagerDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [CBCentralManagerDelegate] that points to the same underlying object as [other].
  CBCentralManagerDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [CBCentralManagerDelegate] that wraps the given raw object pointer.
  CBCentralManagerDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CBCentralManagerDelegate].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_CBCentralManagerDelegate,
    );
  }
}

extension CBCentralManagerDelegate$Methods on CBCentralManagerDelegate {
  /// centralManager:connectionEventDidOccur:forPeripheral:
  void centralManager(
    CBCentralManager central, {
    required CBConnectionEvent connectionEventDidOccur,
    required CBPeripheral forPeripheral,
  }) {
    objc.checkOsVersionInternal(
      'CBCentralManagerDelegate.centralManager:connectionEventDidOccur:forPeripheral:',
      iOS: (false, (13, 0, 0)),
      macOS: (true, null),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_centralManager_connectionEventDidOccur_forPeripheral_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBCentralManagerDelegate',
        'centralManager:connectionEventDidOccur:forPeripheral:',
      );
    }
    _objc_msgSend_11np4se(
      object$.ref.pointer,
      _sel_centralManager_connectionEventDidOccur_forPeripheral_,
      central.ref.pointer,
      connectionEventDidOccur.value,
      forPeripheral.ref.pointer,
    );
  }

  /// centralManager:didConnectPeripheral:
  void centralManager$1(
    CBCentralManager central, {
    required CBPeripheral didConnectPeripheral,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_centralManager_didConnectPeripheral_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBCentralManagerDelegate',
        'centralManager:didConnectPeripheral:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_centralManager_didConnectPeripheral_,
      central.ref.pointer,
      didConnectPeripheral.ref.pointer,
    );
  }

  /// centralManager:didDisconnectPeripheral:error:
  void centralManager$2(
    CBCentralManager central, {
    required CBPeripheral didDisconnectPeripheral,
    objc.NSError? error,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_centralManager_didDisconnectPeripheral_error_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBCentralManagerDelegate',
        'centralManager:didDisconnectPeripheral:error:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_centralManager_didDisconnectPeripheral_error_,
      central.ref.pointer,
      didDisconnectPeripheral.ref.pointer,
      error?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// centralManager:didDisconnectPeripheral:timestamp:isReconnecting:error:
  void centralManager$3(
    CBCentralManager central, {
    required CBPeripheral didDisconnectPeripheral,
    required double timestamp,
    required bool isReconnecting,
    objc.NSError? error,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBCentralManagerDelegate',
        'centralManager:didDisconnectPeripheral:timestamp:isReconnecting:error:',
      );
    }
    _objc_msgSend_1xnaqp0(
      object$.ref.pointer,
      _sel_centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
      central.ref.pointer,
      didDisconnectPeripheral.ref.pointer,
      timestamp,
      isReconnecting,
      error?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// centralManager:didDiscoverPeripheral:advertisementData:RSSI:
  void centralManager$4(
    CBCentralManager central, {
    required CBPeripheral didDiscoverPeripheral,
    required objc.NSDictionary advertisementData,
    required objc.NSNumber RSSI,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBCentralManagerDelegate',
        'centralManager:didDiscoverPeripheral:advertisementData:RSSI:',
      );
    }
    _objc_msgSend_mlcr8l(
      object$.ref.pointer,
      _sel_centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
      central.ref.pointer,
      didDiscoverPeripheral.ref.pointer,
      advertisementData.ref.pointer,
      RSSI.ref.pointer,
    );
  }

  /// centralManager:didFailToConnectPeripheral:error:
  void centralManager$5(
    CBCentralManager central, {
    required CBPeripheral didFailToConnectPeripheral,
    objc.NSError? error,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_centralManager_didFailToConnectPeripheral_error_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBCentralManagerDelegate',
        'centralManager:didFailToConnectPeripheral:error:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_centralManager_didFailToConnectPeripheral_error_,
      central.ref.pointer,
      didFailToConnectPeripheral.ref.pointer,
      error?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// centralManager:didUpdateANCSAuthorizationForPeripheral:
  void centralManager$6(
    CBCentralManager central, {
    required CBPeripheral didUpdateANCSAuthorizationForPeripheral,
  }) {
    objc.checkOsVersionInternal(
      'CBCentralManagerDelegate.centralManager:didUpdateANCSAuthorizationForPeripheral:',
      iOS: (false, (13, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_centralManager_didUpdateANCSAuthorizationForPeripheral_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBCentralManagerDelegate',
        'centralManager:didUpdateANCSAuthorizationForPeripheral:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_centralManager_didUpdateANCSAuthorizationForPeripheral_,
      central.ref.pointer,
      didUpdateANCSAuthorizationForPeripheral.ref.pointer,
    );
  }

  /// centralManager:willRestoreState:
  void centralManager$7(
    CBCentralManager central, {
    required objc.NSDictionary willRestoreState,
  }) {
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_centralManager_willRestoreState_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'CBCentralManagerDelegate',
        'centralManager:willRestoreState:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_centralManager_willRestoreState_,
      central.ref.pointer,
      willRestoreState.ref.pointer,
    );
  }

  /// centralManagerDidUpdateState:
  void centralManagerDidUpdateState(CBCentralManager central) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_centralManagerDidUpdateState_,
      central.ref.pointer,
    );
  }
}

interface class CBCentralManagerDelegate$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.fromPointer(_protocol_CBCentralManagerDelegate.cast());

  /// Builds an object that implements the CBCentralManagerDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CBCentralManagerDelegate implement({
    void Function(CBCentralManager, CBConnectionEvent, CBPeripheral)?
    centralManager_connectionEventDidOccur_forPeripheral_,
    void Function(CBCentralManager, CBPeripheral)?
    centralManager_didConnectPeripheral_,
    void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
    centralManager_didDisconnectPeripheral_error_,
    void Function(CBCentralManager, CBPeripheral, double, bool, objc.NSError?)?
    centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
    void Function(
      CBCentralManager,
      CBPeripheral,
      objc.NSDictionary,
      objc.NSNumber,
    )?
    centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
    void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
    centralManager_didFailToConnectPeripheral_error_,
    void Function(CBCentralManager, CBPeripheral)?
    centralManager_didUpdateANCSAuthorizationForPeripheral_,
    void Function(CBCentralManager, objc.NSDictionary)?
    centralManager_willRestoreState_,
    required void Function(CBCentralManager) centralManagerDidUpdateState_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'CBCentralManagerDelegate',
    );
    CBCentralManagerDelegate$Builder
        .centralManager_connectionEventDidOccur_forPeripheral_
        .implement(
          builder,
          centralManager_connectionEventDidOccur_forPeripheral_,
        );
    CBCentralManagerDelegate$Builder.centralManager_didConnectPeripheral_
        .implement(builder, centralManager_didConnectPeripheral_);
    CBCentralManagerDelegate$Builder
        .centralManager_didDisconnectPeripheral_error_
        .implement(builder, centralManager_didDisconnectPeripheral_error_);
    CBCentralManagerDelegate$Builder
        .centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_
        .implement(
          builder,
          centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didDiscoverPeripheral_advertisementData_RSSI_
        .implement(
          builder,
          centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didFailToConnectPeripheral_error_
        .implement(builder, centralManager_didFailToConnectPeripheral_error_);
    CBCentralManagerDelegate$Builder
        .centralManager_didUpdateANCSAuthorizationForPeripheral_
        .implement(
          builder,
          centralManager_didUpdateANCSAuthorizationForPeripheral_,
        );
    CBCentralManagerDelegate$Builder.centralManager_willRestoreState_.implement(
      builder,
      centralManager_willRestoreState_,
    );
    CBCentralManagerDelegate$Builder.centralManagerDidUpdateState_.implement(
      builder,
      centralManagerDidUpdateState_,
    );
    builder.addProtocol($protocol);
    return CBCentralManagerDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the CBCentralManagerDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    void Function(CBCentralManager, CBConnectionEvent, CBPeripheral)?
    centralManager_connectionEventDidOccur_forPeripheral_,
    void Function(CBCentralManager, CBPeripheral)?
    centralManager_didConnectPeripheral_,
    void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
    centralManager_didDisconnectPeripheral_error_,
    void Function(CBCentralManager, CBPeripheral, double, bool, objc.NSError?)?
    centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
    void Function(
      CBCentralManager,
      CBPeripheral,
      objc.NSDictionary,
      objc.NSNumber,
    )?
    centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
    void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
    centralManager_didFailToConnectPeripheral_error_,
    void Function(CBCentralManager, CBPeripheral)?
    centralManager_didUpdateANCSAuthorizationForPeripheral_,
    void Function(CBCentralManager, objc.NSDictionary)?
    centralManager_willRestoreState_,
    required void Function(CBCentralManager) centralManagerDidUpdateState_,
    bool $keepIsolateAlive = true,
  }) {
    CBCentralManagerDelegate$Builder
        .centralManager_connectionEventDidOccur_forPeripheral_
        .implement(
          builder,
          centralManager_connectionEventDidOccur_forPeripheral_,
        );
    CBCentralManagerDelegate$Builder.centralManager_didConnectPeripheral_
        .implement(builder, centralManager_didConnectPeripheral_);
    CBCentralManagerDelegate$Builder
        .centralManager_didDisconnectPeripheral_error_
        .implement(builder, centralManager_didDisconnectPeripheral_error_);
    CBCentralManagerDelegate$Builder
        .centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_
        .implement(
          builder,
          centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didDiscoverPeripheral_advertisementData_RSSI_
        .implement(
          builder,
          centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didFailToConnectPeripheral_error_
        .implement(builder, centralManager_didFailToConnectPeripheral_error_);
    CBCentralManagerDelegate$Builder
        .centralManager_didUpdateANCSAuthorizationForPeripheral_
        .implement(
          builder,
          centralManager_didUpdateANCSAuthorizationForPeripheral_,
        );
    CBCentralManagerDelegate$Builder.centralManager_willRestoreState_.implement(
      builder,
      centralManager_willRestoreState_,
    );
    CBCentralManagerDelegate$Builder.centralManagerDidUpdateState_.implement(
      builder,
      centralManagerDidUpdateState_,
    );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the CBCentralManagerDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CBCentralManagerDelegate implementAsListener({
    void Function(CBCentralManager, CBConnectionEvent, CBPeripheral)?
    centralManager_connectionEventDidOccur_forPeripheral_,
    void Function(CBCentralManager, CBPeripheral)?
    centralManager_didConnectPeripheral_,
    void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
    centralManager_didDisconnectPeripheral_error_,
    void Function(CBCentralManager, CBPeripheral, double, bool, objc.NSError?)?
    centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
    void Function(
      CBCentralManager,
      CBPeripheral,
      objc.NSDictionary,
      objc.NSNumber,
    )?
    centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
    void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
    centralManager_didFailToConnectPeripheral_error_,
    void Function(CBCentralManager, CBPeripheral)?
    centralManager_didUpdateANCSAuthorizationForPeripheral_,
    void Function(CBCentralManager, objc.NSDictionary)?
    centralManager_willRestoreState_,
    required void Function(CBCentralManager) centralManagerDidUpdateState_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'CBCentralManagerDelegate',
    );
    CBCentralManagerDelegate$Builder
        .centralManager_connectionEventDidOccur_forPeripheral_
        .implementAsListener(
          builder,
          centralManager_connectionEventDidOccur_forPeripheral_,
        );
    CBCentralManagerDelegate$Builder.centralManager_didConnectPeripheral_
        .implementAsListener(builder, centralManager_didConnectPeripheral_);
    CBCentralManagerDelegate$Builder
        .centralManager_didDisconnectPeripheral_error_
        .implementAsListener(
          builder,
          centralManager_didDisconnectPeripheral_error_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_
        .implementAsListener(
          builder,
          centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didDiscoverPeripheral_advertisementData_RSSI_
        .implementAsListener(
          builder,
          centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didFailToConnectPeripheral_error_
        .implementAsListener(
          builder,
          centralManager_didFailToConnectPeripheral_error_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didUpdateANCSAuthorizationForPeripheral_
        .implementAsListener(
          builder,
          centralManager_didUpdateANCSAuthorizationForPeripheral_,
        );
    CBCentralManagerDelegate$Builder.centralManager_willRestoreState_
        .implementAsListener(builder, centralManager_willRestoreState_);
    CBCentralManagerDelegate$Builder.centralManagerDidUpdateState_
        .implementAsListener(builder, centralManagerDidUpdateState_);
    builder.addProtocol($protocol);
    return CBCentralManagerDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the CBCentralManagerDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(
    objc.ObjCProtocolBuilder builder, {
    void Function(CBCentralManager, CBConnectionEvent, CBPeripheral)?
    centralManager_connectionEventDidOccur_forPeripheral_,
    void Function(CBCentralManager, CBPeripheral)?
    centralManager_didConnectPeripheral_,
    void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
    centralManager_didDisconnectPeripheral_error_,
    void Function(CBCentralManager, CBPeripheral, double, bool, objc.NSError?)?
    centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
    void Function(
      CBCentralManager,
      CBPeripheral,
      objc.NSDictionary,
      objc.NSNumber,
    )?
    centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
    void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
    centralManager_didFailToConnectPeripheral_error_,
    void Function(CBCentralManager, CBPeripheral)?
    centralManager_didUpdateANCSAuthorizationForPeripheral_,
    void Function(CBCentralManager, objc.NSDictionary)?
    centralManager_willRestoreState_,
    required void Function(CBCentralManager) centralManagerDidUpdateState_,
    bool $keepIsolateAlive = true,
  }) {
    CBCentralManagerDelegate$Builder
        .centralManager_connectionEventDidOccur_forPeripheral_
        .implementAsListener(
          builder,
          centralManager_connectionEventDidOccur_forPeripheral_,
        );
    CBCentralManagerDelegate$Builder.centralManager_didConnectPeripheral_
        .implementAsListener(builder, centralManager_didConnectPeripheral_);
    CBCentralManagerDelegate$Builder
        .centralManager_didDisconnectPeripheral_error_
        .implementAsListener(
          builder,
          centralManager_didDisconnectPeripheral_error_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_
        .implementAsListener(
          builder,
          centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didDiscoverPeripheral_advertisementData_RSSI_
        .implementAsListener(
          builder,
          centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didFailToConnectPeripheral_error_
        .implementAsListener(
          builder,
          centralManager_didFailToConnectPeripheral_error_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didUpdateANCSAuthorizationForPeripheral_
        .implementAsListener(
          builder,
          centralManager_didUpdateANCSAuthorizationForPeripheral_,
        );
    CBCentralManagerDelegate$Builder.centralManager_willRestoreState_
        .implementAsListener(builder, centralManager_willRestoreState_);
    CBCentralManagerDelegate$Builder.centralManagerDidUpdateState_
        .implementAsListener(builder, centralManagerDidUpdateState_);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the CBCentralManagerDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CBCentralManagerDelegate implementAsBlocking({
    void Function(CBCentralManager, CBConnectionEvent, CBPeripheral)?
    centralManager_connectionEventDidOccur_forPeripheral_,
    void Function(CBCentralManager, CBPeripheral)?
    centralManager_didConnectPeripheral_,
    void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
    centralManager_didDisconnectPeripheral_error_,
    void Function(CBCentralManager, CBPeripheral, double, bool, objc.NSError?)?
    centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
    void Function(
      CBCentralManager,
      CBPeripheral,
      objc.NSDictionary,
      objc.NSNumber,
    )?
    centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
    void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
    centralManager_didFailToConnectPeripheral_error_,
    void Function(CBCentralManager, CBPeripheral)?
    centralManager_didUpdateANCSAuthorizationForPeripheral_,
    void Function(CBCentralManager, objc.NSDictionary)?
    centralManager_willRestoreState_,
    required void Function(CBCentralManager) centralManagerDidUpdateState_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'CBCentralManagerDelegate',
    );
    CBCentralManagerDelegate$Builder
        .centralManager_connectionEventDidOccur_forPeripheral_
        .implementAsBlocking(
          builder,
          centralManager_connectionEventDidOccur_forPeripheral_,
        );
    CBCentralManagerDelegate$Builder.centralManager_didConnectPeripheral_
        .implementAsBlocking(builder, centralManager_didConnectPeripheral_);
    CBCentralManagerDelegate$Builder
        .centralManager_didDisconnectPeripheral_error_
        .implementAsBlocking(
          builder,
          centralManager_didDisconnectPeripheral_error_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_
        .implementAsBlocking(
          builder,
          centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didDiscoverPeripheral_advertisementData_RSSI_
        .implementAsBlocking(
          builder,
          centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didFailToConnectPeripheral_error_
        .implementAsBlocking(
          builder,
          centralManager_didFailToConnectPeripheral_error_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didUpdateANCSAuthorizationForPeripheral_
        .implementAsBlocking(
          builder,
          centralManager_didUpdateANCSAuthorizationForPeripheral_,
        );
    CBCentralManagerDelegate$Builder.centralManager_willRestoreState_
        .implementAsBlocking(builder, centralManager_willRestoreState_);
    CBCentralManagerDelegate$Builder.centralManagerDidUpdateState_
        .implementAsBlocking(builder, centralManagerDidUpdateState_);
    builder.addProtocol($protocol);
    return CBCentralManagerDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the CBCentralManagerDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(
    objc.ObjCProtocolBuilder builder, {
    void Function(CBCentralManager, CBConnectionEvent, CBPeripheral)?
    centralManager_connectionEventDidOccur_forPeripheral_,
    void Function(CBCentralManager, CBPeripheral)?
    centralManager_didConnectPeripheral_,
    void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
    centralManager_didDisconnectPeripheral_error_,
    void Function(CBCentralManager, CBPeripheral, double, bool, objc.NSError?)?
    centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
    void Function(
      CBCentralManager,
      CBPeripheral,
      objc.NSDictionary,
      objc.NSNumber,
    )?
    centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
    void Function(CBCentralManager, CBPeripheral, objc.NSError?)?
    centralManager_didFailToConnectPeripheral_error_,
    void Function(CBCentralManager, CBPeripheral)?
    centralManager_didUpdateANCSAuthorizationForPeripheral_,
    void Function(CBCentralManager, objc.NSDictionary)?
    centralManager_willRestoreState_,
    required void Function(CBCentralManager) centralManagerDidUpdateState_,
    bool $keepIsolateAlive = true,
  }) {
    CBCentralManagerDelegate$Builder
        .centralManager_connectionEventDidOccur_forPeripheral_
        .implementAsBlocking(
          builder,
          centralManager_connectionEventDidOccur_forPeripheral_,
        );
    CBCentralManagerDelegate$Builder.centralManager_didConnectPeripheral_
        .implementAsBlocking(builder, centralManager_didConnectPeripheral_);
    CBCentralManagerDelegate$Builder
        .centralManager_didDisconnectPeripheral_error_
        .implementAsBlocking(
          builder,
          centralManager_didDisconnectPeripheral_error_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_
        .implementAsBlocking(
          builder,
          centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didDiscoverPeripheral_advertisementData_RSSI_
        .implementAsBlocking(
          builder,
          centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didFailToConnectPeripheral_error_
        .implementAsBlocking(
          builder,
          centralManager_didFailToConnectPeripheral_error_,
        );
    CBCentralManagerDelegate$Builder
        .centralManager_didUpdateANCSAuthorizationForPeripheral_
        .implementAsBlocking(
          builder,
          centralManager_didUpdateANCSAuthorizationForPeripheral_,
        );
    CBCentralManagerDelegate$Builder.centralManager_willRestoreState_
        .implementAsBlocking(builder, centralManager_willRestoreState_);
    CBCentralManagerDelegate$Builder.centralManagerDidUpdateState_
        .implementAsBlocking(builder, centralManagerDidUpdateState_);
    builder.addProtocol($protocol);
  }

  /// centralManager:connectionEventDidOccur:forPeripheral:
  static final centralManager_connectionEventDidOccur_forPeripheral_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBCentralManager, CBConnectionEvent, CBPeripheral)
      >(
        _protocol_CBCentralManagerDelegate,
        _sel_centralManager_connectionEventDidOccur_forPeripheral_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Long,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_5ut4yu)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBCentralManagerDelegate,
          _sel_centralManager_connectionEventDidOccur_forPeripheral_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(CBCentralManager, CBConnectionEvent, CBPeripheral) func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBConnectionEvent arg2,
                CBPeripheral arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(CBCentralManager, CBConnectionEvent, CBPeripheral) func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBConnectionEvent arg2,
                CBPeripheral arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(CBCentralManager, CBConnectionEvent, CBPeripheral) func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBConnectionEvent_CBPeripheral.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBConnectionEvent arg2,
                CBPeripheral arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// centralManager:didConnectPeripheral:
  static final centralManager_didConnectPeripheral_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBCentralManager, CBPeripheral)
      >(
        _protocol_CBCentralManagerDelegate,
        _sel_centralManager_didConnectPeripheral_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBCentralManagerDelegate,
          _sel_centralManager_didConnectPeripheral_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBCentralManager, CBPeripheral) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(CBCentralManager, CBPeripheral) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(CBCentralManager, CBPeripheral) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// centralManager:didDisconnectPeripheral:error:
  static final centralManager_didDisconnectPeripheral_error_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBCentralManager, CBPeripheral, objc.NSError?)
      >(
        _protocol_CBCentralManagerDelegate,
        _sel_centralManager_didDisconnectPeripheral_error_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBCentralManagerDelegate,
          _sel_centralManager_didDisconnectPeripheral_error_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBCentralManager, CBPeripheral, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBCentralManager, CBPeripheral, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBCentralManager, CBPeripheral, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// centralManager:didDisconnectPeripheral:timestamp:isReconnecting:error:
  static final centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          CBCentralManager,
          CBPeripheral,
          double,
          bool,
          objc.NSError?,
        )
      >(
        _protocol_CBCentralManagerDelegate,
        _sel_centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Double,
                  ffi.Bool,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_o4q9mk)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBCentralManagerDelegate,
          _sel_centralManager_didDisconnectPeripheral_timestamp_isReconnecting_error_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            CBCentralManager,
            CBPeripheral,
            double,
            bool,
            objc.NSError?,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
                double arg3,
                bool arg4,
                objc.NSError? arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (
          void Function(
            CBCentralManager,
            CBPeripheral,
            double,
            bool,
            objc.NSError?,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
                double arg3,
                bool arg4,
                objc.NSError? arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (
          void Function(
            CBCentralManager,
            CBPeripheral,
            double,
            bool,
            objc.NSError?,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_CFAbsoluteTime_bool_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
                double arg3,
                bool arg4,
                objc.NSError? arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
      );

  /// centralManager:didDiscoverPeripheral:advertisementData:RSSI:
  static final centralManager_didDiscoverPeripheral_advertisementData_RSSI_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          CBCentralManager,
          CBPeripheral,
          objc.NSDictionary,
          objc.NSNumber,
        )
      >(
        _protocol_CBCentralManagerDelegate,
        _sel_centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_8jfq1p)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBCentralManagerDelegate,
          _sel_centralManager_didDiscoverPeripheral_advertisementData_RSSI_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            CBCentralManager,
            CBPeripheral,
            objc.NSDictionary,
            objc.NSNumber,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
                objc.NSDictionary arg3,
                objc.NSNumber arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            CBCentralManager,
            CBPeripheral,
            objc.NSDictionary,
            objc.NSNumber,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
                objc.NSDictionary arg3,
                objc.NSNumber arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            CBCentralManager,
            CBPeripheral,
            objc.NSDictionary,
            objc.NSNumber,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSDictionary_NSNumber.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
                objc.NSDictionary arg3,
                objc.NSNumber arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// centralManager:didFailToConnectPeripheral:error:
  static final centralManager_didFailToConnectPeripheral_error_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBCentralManager, CBPeripheral, objc.NSError?)
      >(
        _protocol_CBCentralManagerDelegate,
        _sel_centralManager_didFailToConnectPeripheral_error_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBCentralManagerDelegate,
          _sel_centralManager_didFailToConnectPeripheral_error_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBCentralManager, CBPeripheral, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBCentralManager, CBPeripheral, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(CBCentralManager, CBPeripheral, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// centralManager:didUpdateANCSAuthorizationForPeripheral:
  static final centralManager_didUpdateANCSAuthorizationForPeripheral_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBCentralManager, CBPeripheral)
      >(
        _protocol_CBCentralManagerDelegate,
        _sel_centralManager_didUpdateANCSAuthorizationForPeripheral_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBCentralManagerDelegate,
          _sel_centralManager_didUpdateANCSAuthorizationForPeripheral_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBCentralManager, CBPeripheral) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(CBCentralManager, CBPeripheral) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(CBCentralManager, CBPeripheral) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_CBPeripheral.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                CBPeripheral arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// centralManager:willRestoreState:
  static final centralManager_willRestoreState_ =
      objc.ObjCProtocolListenableMethod<
        void Function(CBCentralManager, objc.NSDictionary)
      >(
        _protocol_CBCentralManagerDelegate,
        _sel_centralManager_willRestoreState_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBCentralManagerDelegate,
          _sel_centralManager_willRestoreState_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(CBCentralManager, objc.NSDictionary) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                objc.NSDictionary arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(CBCentralManager, objc.NSDictionary) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary.listener(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                objc.NSDictionary arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(CBCentralManager, objc.NSDictionary) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager_NSDictionary.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                CBCentralManager arg1,
                objc.NSDictionary arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// centralManagerDidUpdateState:
  static final centralManagerDidUpdateState_ =
      objc.ObjCProtocolListenableMethod<void Function(CBCentralManager)>(
        _protocol_CBCentralManagerDelegate,
        _sel_centralManagerDidUpdateState_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_CoreBluetoothBindings_protocolTrampoline_18v1jvf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_CBCentralManagerDelegate,
          _sel_centralManagerDidUpdateState_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (void Function(CBCentralManager) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager.fromFunction(
              (ffi.Pointer<ffi.Void> _, CBCentralManager arg1) => func(arg1),
            ),
        (void Function(CBCentralManager) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager.listener(
              (ffi.Pointer<ffi.Void> _, CBCentralManager arg1) => func(arg1),
            ),
        (void Function(CBCentralManager) func) =>
            ObjCBlock_ffiVoid_ffiVoid_CBCentralManager.blocking(
              (ffi.Pointer<ffi.Void> _, CBCentralManager arg1) => func(arg1),
            ),
      );
}

late final _sel_isScanning = objc.registerName("isScanning");
late final _sel_supportsFeatures_ = objc.registerName("supportsFeatures:");
final _objc_msgSend_172tl3q = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_initWithDelegate_queue_ = objc.registerName(
  "initWithDelegate:queue:",
);
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithDelegate_queue_options_ = objc.registerName(
  "initWithDelegate:queue:options:",
);
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_retrievePeripheralsWithIdentifiers_ = objc.registerName(
  "retrievePeripheralsWithIdentifiers:",
);
late final _sel_retrieveConnectedPeripheralsWithServices_ = objc.registerName(
  "retrieveConnectedPeripheralsWithServices:",
);
late final _sel_scanForPeripheralsWithServices_options_ = objc.registerName(
  "scanForPeripheralsWithServices:options:",
);
late final _sel_stopScan = objc.registerName("stopScan");
late final _sel_connectPeripheral_options_ = objc.registerName(
  "connectPeripheral:options:",
);
late final _sel_cancelPeripheralConnection_ = objc.registerName(
  "cancelPeripheralConnection:",
);
late final _sel_registerForConnectionEventsWithOptions_ = objc.registerName(
  "registerForConnectionEventsWithOptions:",
);

/// CBCentralManager
extension type CBCentralManager._(objc.ObjCObject object$)
    implements objc.ObjCObject, CBManager {
  /// Constructs a [CBCentralManager] that points to the same underlying object as [other].
  CBCentralManager.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal('CBCentralManager', iOS: (false, (5, 0, 0)));
    assert(isA(object$));
  }

  /// Constructs a [CBCentralManager] that wraps the given raw object pointer.
  CBCentralManager.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal('CBCentralManager', iOS: (false, (5, 0, 0)));
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [CBCentralManager].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_CBCentralManager,
  );

  /// alloc
  static CBCentralManager alloc() {
    final $ret = _objc_msgSend_151sglz(_class_CBCentralManager, _sel_alloc);
    return CBCentralManager.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CBCentralManager allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_CBCentralManager,
      _sel_allocWithZone_,
      zone,
    );
    return CBCentralManager.fromPointer($ret, retain: false, release: true);
  }

  /// authorization
  static CBManagerAuthorization getAuthorization$1() {
    objc.checkOsVersionInternal(
      'CBCentralManager.authorization',
      iOS: (false, (13, 1, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1pjspfw(
      _class_CBCentralManager,
      _sel_authorization,
    );
    return CBManagerAuthorization.fromValue($ret);
  }

  /// new
  static CBCentralManager new$() {
    final $ret = _objc_msgSend_151sglz(_class_CBCentralManager, _sel_new);
    return CBCentralManager.fromPointer($ret, retain: false, release: true);
  }

  /// supportsFeatures:
  static bool supportsFeatures(int features) {
    objc.checkOsVersionInternal(
      'CBCentralManager.supportsFeatures:',
      iOS: (false, (13, 0, 0)),
      macOS: (true, null),
    );
    return _objc_msgSend_172tl3q(
      _class_CBCentralManager,
      _sel_supportsFeatures_,
      features,
    );
  }

  /// Returns a new instance of CBCentralManager constructed with the default `new` method.
  CBCentralManager() : this.as(new$().object$);
}

extension CBCentralManager$Methods on CBCentralManager {
  /// cancelPeripheralConnection:
  void cancelPeripheralConnection(CBPeripheral peripheral) {
    objc.checkOsVersionInternal(
      'CBCentralManager.cancelPeripheralConnection:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_cancelPeripheralConnection_,
      peripheral.ref.pointer,
    );
  }

  /// connectPeripheral:options:
  void connectPeripheral(
    CBPeripheral peripheral, {
    objc.NSDictionary? options,
  }) {
    objc.checkOsVersionInternal(
      'CBCentralManager.connectPeripheral:options:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_connectPeripheral_options_,
      peripheral.ref.pointer,
      options?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// delegate
  CBCentralManagerDelegate? get delegate {
    objc.checkOsVersionInternal(
      'CBCentralManager.delegate',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_delegate);
    return $ret.address == 0
        ? null
        : CBCentralManagerDelegate.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// init
  CBCentralManager init() {
    objc.checkOsVersionInternal(
      'CBCentralManager.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return CBCentralManager.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDelegate:queue:
  CBCentralManager initWithDelegate(
    CBCentralManagerDelegate? delegate, {
    objc.NSObject? queue,
  }) {
    objc.checkOsVersionInternal(
      'CBCentralManager.initWithDelegate:queue:',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDelegate_queue_,
      delegate?.ref.pointer ?? ffi.nullptr,
      queue?.ref.pointer ?? ffi.nullptr,
    );
    return CBCentralManager.fromPointer($ret, retain: false, release: true);
  }

  /// initWithDelegate:queue:options:
  CBCentralManager initWithDelegate$1(
    CBCentralManagerDelegate? delegate, {
    objc.NSObject? queue,
    objc.NSDictionary? options,
  }) {
    objc.checkOsVersionInternal(
      'CBCentralManager.initWithDelegate:queue:options:',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithDelegate_queue_options_,
      delegate?.ref.pointer ?? ffi.nullptr,
      queue?.ref.pointer ?? ffi.nullptr,
      options?.ref.pointer ?? ffi.nullptr,
    );
    return CBCentralManager.fromPointer($ret, retain: false, release: true);
  }

  /// isScanning
  bool get isScanning {
    objc.checkOsVersionInternal(
      'CBCentralManager.isScanning',
      iOS: (false, (9, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isScanning);
  }

  /// registerForConnectionEventsWithOptions:
  void registerForConnectionEventsWithOptions(objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
      'CBCentralManager.registerForConnectionEventsWithOptions:',
      iOS: (false, (13, 0, 0)),
      macOS: (true, null),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_registerForConnectionEventsWithOptions_,
      options?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// retrieveConnectedPeripheralsWithServices:
  objc.NSArray retrieveConnectedPeripheralsWithServices(
    objc.NSArray serviceUUIDs,
  ) {
    objc.checkOsVersionInternal(
      'CBCentralManager.retrieveConnectedPeripheralsWithServices:',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_retrieveConnectedPeripheralsWithServices_,
      serviceUUIDs.ref.pointer,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// retrievePeripheralsWithIdentifiers:
  objc.NSArray retrievePeripheralsWithIdentifiers(objc.NSArray identifiers) {
    objc.checkOsVersionInternal(
      'CBCentralManager.retrievePeripheralsWithIdentifiers:',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_retrievePeripheralsWithIdentifiers_,
      identifiers.ref.pointer,
    );
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// scanForPeripheralsWithServices:options:
  void scanForPeripheralsWithServices(
    objc.NSArray? serviceUUIDs, {
    objc.NSDictionary? options,
  }) {
    objc.checkOsVersionInternal(
      'CBCentralManager.scanForPeripheralsWithServices:options:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_scanForPeripheralsWithServices_options_,
      serviceUUIDs?.ref.pointer ?? ffi.nullptr,
      options?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setDelegate:
  set delegate(CBCentralManagerDelegate? value) {
    objc.checkOsVersionInternal(
      'CBCentralManager.setDelegate:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setDelegate_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// stopScan
  void stopScan() {
    objc.checkOsVersionInternal(
      'CBCentralManager.stopScan',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_stopScan);
  }
}

enum CBError {
  CBErrorUnknown(0),
  CBErrorInvalidParameters(1),
  CBErrorInvalidHandle(2),
  CBErrorNotConnected(3),
  CBErrorOutOfSpace(4),
  CBErrorOperationCancelled(5),
  CBErrorConnectionTimeout(6),
  CBErrorPeripheralDisconnected(7),
  CBErrorUUIDNotAllowed(8),
  CBErrorAlreadyAdvertising(9),
  CBErrorConnectionFailed(10),
  CBErrorConnectionLimitReached(11),
  CBErrorUnkownDevice(12),
  CBErrorOperationNotSupported(13),
  CBErrorPeerRemovedPairingInformation(14),
  CBErrorEncryptionTimedOut(15),
  CBErrorTooManyLEPairedDevices(16),
  CBErrorLeGattExceededBackgroundNotificationLimit(17),
  CBErrorLeGattNearBackgroundNotificationLimit(18);

  static const CBErrorUnknownDevice = CBErrorUnkownDevice;

  final int value;
  const CBError(this.value);

  static CBError fromValue(int value) => switch (value) {
    0 => CBErrorUnknown,
    1 => CBErrorInvalidParameters,
    2 => CBErrorInvalidHandle,
    3 => CBErrorNotConnected,
    4 => CBErrorOutOfSpace,
    5 => CBErrorOperationCancelled,
    6 => CBErrorConnectionTimeout,
    7 => CBErrorPeripheralDisconnected,
    8 => CBErrorUUIDNotAllowed,
    9 => CBErrorAlreadyAdvertising,
    10 => CBErrorConnectionFailed,
    11 => CBErrorConnectionLimitReached,
    12 => CBErrorUnkownDevice,
    13 => CBErrorOperationNotSupported,
    14 => CBErrorPeerRemovedPairingInformation,
    15 => CBErrorEncryptionTimedOut,
    16 => CBErrorTooManyLEPairedDevices,
    17 => CBErrorLeGattExceededBackgroundNotificationLimit,
    18 => CBErrorLeGattNearBackgroundNotificationLimit,
    _ => throw ArgumentError('Unknown value for CBError: $value'),
  };

  @override
  String toString() {
    if (this == CBErrorUnkownDevice)
      return "CBError.CBErrorUnkownDevice, CBError.CBErrorUnknownDevice";
    return super.toString();
  }
}

enum CBATTError {
  CBATTErrorSuccess(0),
  CBATTErrorInvalidHandle(1),
  CBATTErrorReadNotPermitted(2),
  CBATTErrorWriteNotPermitted(3),
  CBATTErrorInvalidPdu(4),
  CBATTErrorInsufficientAuthentication(5),
  CBATTErrorRequestNotSupported(6),
  CBATTErrorInvalidOffset(7),
  CBATTErrorInsufficientAuthorization(8),
  CBATTErrorPrepareQueueFull(9),
  CBATTErrorAttributeNotFound(10),
  CBATTErrorAttributeNotLong(11),
  CBATTErrorInsufficientEncryptionKeySize(12),
  CBATTErrorInvalidAttributeValueLength(13),
  CBATTErrorUnlikelyError(14),
  CBATTErrorInsufficientEncryption(15),
  CBATTErrorUnsupportedGroupType(16),
  CBATTErrorInsufficientResources(17);

  final int value;
  const CBATTError(this.value);

  static CBATTError fromValue(int value) => switch (value) {
    0 => CBATTErrorSuccess,
    1 => CBATTErrorInvalidHandle,
    2 => CBATTErrorReadNotPermitted,
    3 => CBATTErrorWriteNotPermitted,
    4 => CBATTErrorInvalidPdu,
    5 => CBATTErrorInsufficientAuthentication,
    6 => CBATTErrorRequestNotSupported,
    7 => CBATTErrorInvalidOffset,
    8 => CBATTErrorInsufficientAuthorization,
    9 => CBATTErrorPrepareQueueFull,
    10 => CBATTErrorAttributeNotFound,
    11 => CBATTErrorAttributeNotLong,
    12 => CBATTErrorInsufficientEncryptionKeySize,
    13 => CBATTErrorInvalidAttributeValueLength,
    14 => CBATTErrorUnlikelyError,
    15 => CBATTErrorInsufficientEncryption,
    16 => CBATTErrorUnsupportedGroupType,
    17 => CBATTErrorInsufficientResources,
    _ => throw ArgumentError('Unknown value for CBATTError: $value'),
  };
}

sealed class CBAttributePermissions {
  static const CBAttributePermissionsReadable = 1;
  static const CBAttributePermissionsWriteable = 2;
  static const CBAttributePermissionsReadEncryptionRequired = 4;
  static const CBAttributePermissionsWriteEncryptionRequired = 8;
}
